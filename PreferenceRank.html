<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--space-xs: 0.5rem;
				--space-sm: 1rem;
				--space-md: 1.5rem;
				--space-lg: 2rem;
				--radius-sm: 4px;
				--radius: 8px;
				--bg: #f9f9ff;
				--bg-container: #ffffff;
				--text: #414754;
				--border: #c1c6d7;
				--btn-hover: #d7d9e5;
			}

			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--bg: #10131b;
					--bg-container: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--btn-hover: #10131b;
				}
			}

			:root.dark {
				--bg: #10131b;
				--bg-container: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--btn-hover: #10131b;
			}

			html {
				box-sizing: border-box;
			}

			*, *::before, *::after {
				box-sizing: inherit;
				margin: 0;
				padding: 0;
			}

			body {
				align-items: center;
				background-color: var(--bg);
				color: var(--text);
				display: flex;
				font-family: sans-serif;
				justify-content: center;
				min-height: 100vh;
				padding: var(--space-sm);
			}

			.container {
				background-color: var(--bg-container);
				border-radius: var(--radius);
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				color: var(--text);
				max-width: 720px;
				padding: var(--space-lg);
				position: relative;
				width: 100%;
			}

			.container:has(#input-section:not(.hidden)) {
				padding-top: 3rem;
			}

			.hidden {
				display: none !important;
			}

			h1, h2 {
				margin: var(--space-xs) 0;
				text-align: left;
			}

			.form-group {
				margin-bottom: var(--space-sm);
			}

			label {
				display: block;
				font-weight: bold;
				margin-bottom: var(--space-xs);
			}

			input, select, textarea, button {
				background-color: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: var(--radius-sm);
				color: var(--text);
				font-size: 1rem;
				padding: var(--space-xs);
				width: 100%;
			}

			textarea {
				min-height: 80px;
				resize: vertical;
			}

			button {
				cursor: pointer;
				transition: background-color 0.2s ease;
			}

			.btn-primary {
				background-color: var(--primary);
				border: none;
				color: #fff;
			}

			.btn-primary:hover {
				background-color: var(--primary-hover);
			}

			.btn-secondary {
				background-color: var(--bg-container);
				color: var(--text);
			}

			.btn-secondary:hover {
				background-color: var(--btn-hover);
			}

			#battle, #restart-btns, #tie-btns {
				display: flex;
				gap: var(--space-sm);
				margin-top: var(--space-sm);
			}

			#battle button, #tie-btns button, #restart-btns button {
				flex: 1;
			}

			#battle button, #tie-btns button {
				font-size: 1.2rem;
				min-height: 100px;
				min-width: 200px;
			}

			#progress {
				font-size: 1.1rem;
				margin-top: var(--space-sm);
				text-align: center;
			}

			#keyboard-tip {
				background-color: var(--bg);
				border: 1px solid var(--border);
				border-radius: var(--radius-sm);
				font-size: 0.85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: 0.9;
				padding: 8px;
				text-align: center;
			}

			#keyboard-tip kbd {
				background-color: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
				display: inline-block;
				font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
				font-size: 0.9em;
				margin: 0 3px;
				padding: 2px 5px;
			}

			#keyboard-tip-toggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: 0.85rem;
				margin: 10px auto 0;
				padding: 0;
				text-align: center;
				text-decoration: underline;
				width: auto;
			}

			.selectors {
				display: flex;
				gap: 8px;
				position: absolute;
				right: var(--space-lg);
				top: var(--space-sm);
			}

			.selectors select {
				font-size: 0.9rem;
				padding: 5px;
				width: auto;
			}

			.checkbox-group {
				align-items: center;
				display: flex;
				gap: 10px;
				margin-bottom: var(--space-sm);
			}

			.checkbox-group input {
				width: auto;
			}

			.checkbox-group label {
				margin-bottom: 0;
			}

			#results table {
				border-collapse: collapse;
				margin-top: var(--space-sm);
				width: 100%;
			}

			#results th, #results td {
				border: 1px solid var(--border);
				padding: var(--space-xs);
				text-align: left;
			}

			#results th {
				background-color: var(--primary);
				color: #fff;
			}

			#undo-btn {
				margin-top: var(--space-sm);
				width: auto;
			}

			#undo-btn:disabled {
				background-color: var(--btn-hover);
				cursor: not-allowed;
			}

			.selected {
				background-color: var(--primary) !important;
				color: #fff !important;
			}

			@media (max-width: 768px) {
				.container {
					padding: var(--space-md);
				}

				.container:has(#input-section:not(.hidden)) {
					padding-top: calc(var(--space-sm) + var(--space-md) + var(--space-xs));
				}

				.selectors {
					gap: 4px;
					right: var(--space-xs);
					top: var(--space-xs);
				}

				.selectors select {
					font-size: 0.8rem;
					padding: 4px;
				}

				#battle, #tie-btns, #restart-btns {
					flex-direction: column;
				}

				#battle button, #tie-btns button {
					min-width: auto;
					width: 100%;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="input-section">
				<h1 id="title"></h1>
				<div class="selectors">
					<select id="lang-select">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="theme-select">
						<option value="auto" id="theme-auto"></option>
						<option value="light" id="theme-light"></option>
						<option value="dark" id="theme-dark"></option>
					</select>
				</div>
				<div class="form-group">
					<label for="item-input" id="item-input-label"></label>
					<textarea id="item-input" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox-group">
					<input type="checkbox" id="allow-ties"/>
					<label for="allow-ties" id="allow-ties-label"></label>
				</div>
				<div class="checkbox-group">
					<input type="checkbox" id="quick-rank"/>
					<label for="quick-rank" id="quick-rank-label"></label>
				</div>
				<button id="start-btn" class="btn-primary"></button>
			</div>
			<div id="battle-section" class="hidden">
				<button id="undo-btn" class="btn-secondary" disabled></button>
				<div id="battle">
					<button id="left-item" class="btn-secondary"></button>
					<button id="right-item" class="btn-secondary"></button>
				</div>
				<div id="tie-btns" class="hidden">
					<button id="tie-btn" class="btn-secondary"></button>
				</div>
				<div id="progress"></div>
				<button id="keyboard-tip-toggle"></button>
				<div id="keyboard-tip" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restart-btns" class="hidden">
				<button id="restart-battle-btn" class="btn-primary"></button>
				<button id="restart-new-btn" class="btn-primary"></button>
			</div>
		</div>
		<script>
			const $ = (id) => document.getElementById(id);

			const translations = {
				en: {
					title: "PreferenceRank",
					themeAuto: "Auto Theme",
					themeLight: "Light",
					themeDark: "Dark",
					itemInputLabel: "Enter items, one per line:",
					allowTiesLabel: "Allow Ties",
					quickRankLabel: "Use Quick Rank (fewer comparisons)",
					alert: "Please enter at least two items.",
					duplicateAlert: "{count} duplicate item(s) were found and have been removed.",
					startBtn: "Start Ranking",
					tieBtn: "It's a Tie",
					undoBtn: "Undo",
					progress: "Progress",
					keyboardTipToggleShow: "Show keyboard shortcuts",
					keyboardTipToggleHide: "Hide keyboard shortcuts",
					keyboardTipWithTies: "Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> or <kbd>↓</kbd> It's a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice",
					keyboardTipNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					results: "Results",
					rank: "Rank",
					item: "Item",
					score: "Score",
					restartBattleBtn: "Restart Battle",
					restartNewBtn: "Start with New Items",
				},
				id: {
					title: "PreferenceRank",
					themeAuto: "Tema Otomatis",
					themeLight: "Terang",
					themeDark: "Gelap",
					itemInputLabel: "Masukkan pilihan, satu per baris:",
					allowTiesLabel: "Izinkan Seri",
					quickRankLabel: "Gunakan Peringkat Cepat (lebih sedikit perbandingan)",
					alert: "Harap masukkan setidaknya dua pilihan.",
					duplicateAlert: "{count} item duplikat ditemukan dan telah dihapus.",
					startBtn: "Mulai Peringkat",
					tieBtn: "Seri",
					undoBtn: "Urungkan",
					progress: "Kemajuan",
					keyboardTipToggleShow: "Tampilkan pintasan papan ketik",
					keyboardTipToggleHide: "Sembunyikan pintasan papan ketik",
					keyboardTipWithTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> atau <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					keyboardTipNoTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					results: "Hasil",
					rank: "Peringkat",
					item: "Nama",
					score: "Skor",
					restartBattleBtn: "Mulai Ulang Pertarungan",
					restartNewBtn: "Mulai dengan Pilihan Baru",
				},
			};

			class PairProvider {
				constructor(n) {
					this.n = n;
				}
				shuffle(a) {
					for (let i = a.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[a[i], a[j]] = [a[j], a[i]];
					}
				}
				markAsCompared(pair) {}
				unmarkAsCompared(pair) {}
			}

			class FullPairProvider extends PairProvider {
				constructor(n) {
					super(n);
					this.pairs = this.generatePairs(n);
					this.shuffle(this.pairs);
				}
				getNextPair(state) {
					return this.pairs[state.progress];
				}
				getTotal() {
					return this.pairs.length;
				}
				generatePairs(n) {
					const pairs = [];
					for (let i = 0; i < n - 1; i++) {
						for (let j = i + 1; j < n; j++) {
							pairs.push([i, j]);
						}
					}
					return pairs;
				}
			}

			class QuickPairProvider extends PairProvider {
				constructor(n) {
					super(n);
					this.comparedPairs = new Set();
				}

				getNextPair(state) {
					const { scores } = state;
					const n = this.n;

					const sortedIndices = Array.from({ length: n }, (_, i) => i)
						.sort((a, b) => scores[b] - scores[a]);

					for (let i = 0; i < n - 1; i++) {
						const p1 = sortedIndices[i];
						const p2 = sortedIndices[i + 1];
						const pair = [Math.min(p1, p2), Math.max(p1, p2)];
						const pairKey = `${pair[0]}-${pair[1]}`;
						if (!this.comparedPairs.has(pairKey)) {
							return pair;
						}
					}

					return null;
				}

				markAsCompared(pair) {
					this.comparedPairs.add(`${pair[0]}-${pair[1]}`);
				}

				unmarkAsCompared(pair) {
					this.comparedPairs.delete(`${pair[0]}-${pair[1]}`);
				}
			}

			class PreferenceRank {
				static RATING = 1000;
				static K = 32;
				static TIMEOUT = 300;

				constructor(translations) {
					this.translations = translations;
					this.state = this.#getInitialState();
					this.#initUI();
					this.#initListeners();
					this.#initLangAndTheme();
				}

				#getInitialState() {
					return {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: false,
						progress: 0,
						total: 0,
						allowTies: false,
						lang: navigator.language?.startsWith("id") ? "id" : "en",
						theme: "auto",
						history: [],
						isChoosing: false,
					};
				}

				#initUI() {
					const uiMap = {
						langSelect: "lang-select",
						themeSelect: "theme-select",
						allowTies: "allow-ties",
						quickRank: "quick-rank",
						startBtn: "start-btn",
						leftItem: "left-item",
						rightItem: "right-item",
						tieBtn: "tie-btn",
						restartBattleBtn: "restart-battle-btn",
						restartNewBtn: "restart-new-btn",
						undoBtn: "undo-btn",
						tipToggle: "keyboard-tip-toggle",
						inputSection: "input-section",
						battleSection: "battle-section",
						results: "results",
						restartBtns: "restart-btns",
						tieBtns: "tie-btns",
						tip: "keyboard-tip",
						progress: "progress",
						itemInput: "item-input",
						title: "title",
						themeAuto: "theme-auto",
						themeLight: "theme-light",
						themeDark: "theme-dark",
						itemInputLabel: "item-input-label",
						allowTiesLabel: "allow-ties-label",
						quickRankLabel: "quick-rank-label",
					};
					this.ui = Object.entries(uiMap).reduce((acc, [key, id]) => {
						acc[key] = $(id);
						return acc;
					}, {});
				}

				#initListeners() {
					const listeners = {
						langSelect: ["change", () => this.#updateLang()],
						themeSelect: ["change", (e) => this.#setTheme(e.target.value)],
						allowTies: ["change", (e) => this.#toggleTies(e.target.checked)],
						startBtn: ["click", () => this.start()],
						leftItem: ["click", () => this.choose("left")],
						rightItem: ["click", () => this.choose("right")],
						tieBtn: ["click", () => this.choose("tie")],
						restartBattleBtn: ["click", () => this.restart()],
						restartNewBtn: ["click", () => this.restartNew()],
						undoBtn: ["click", () => this.undo()],
						tipToggle: ["click", () => this.#toggleTip()],
					};
					for (const [key, [event, handler]] of Object.entries(listeners)) {
						this.ui[key]?.addEventListener(event, handler);
					}
					document.addEventListener("keydown", (e) => this.#onKeyDown(e));
				}

				#initLangAndTheme() {
					this.ui.langSelect.value = this.state.lang;
					this.#applyTheme();
					this.#updateLang();
				}

				#t(key, replacements = {}) {
					let text = this.translations[this.state.lang][key] || key;
					for (const [p, v] of Object.entries(replacements)) {
						text = text.replace(`{${p}}`, v);
					}
					return text;
				}

				#setTheme(theme) {
					this.state.theme = theme;
					this.#applyTheme();
				}

				#applyTheme() {
					document.documentElement.classList.remove("light", "dark");
					if (this.state.theme !== "auto") {
						document.documentElement.classList.add(this.state.theme);
					}
				}

				#updateLang() {
					this.state.lang = this.ui.langSelect.value;
					const textMap = {
						title: "title",
						themeAuto: "themeAuto",
						themeLight: "themeLight",
						themeDark: "themeDark",
						itemInputLabel: "itemInputLabel",
						allowTiesLabel: "allowTiesLabel",
						quickRankLabel: "quickRankLabel",
						startBtn: "startBtn",
						tieBtn: "tieBtn",
						undoBtn: "undoBtn",
						restartBattleBtn: "restartBattleBtn",
						restartNewBtn: "restartNewBtn",
					};
					for (const [uiKey, transKey] of Object.entries(textMap)) {
						this.ui[uiKey].textContent = this.#t(transKey);
					}
					this.#updateTip();
					this.ui.tipToggle.textContent = this.#t(this.ui.tip.classList.contains("hidden") ? "keyboardTipToggleShow" : "keyboardTipToggleHide");
					this.#updateProgress();
					if (!this.ui.results.classList.contains("hidden")) this.showResults();
				}

				#toggleTies(isChecked) {
					this.state.allowTies = isChecked;
					if (!this.ui.battleSection.classList.contains("hidden")) {
						this.ui.tieBtns.classList.toggle("hidden", !this.state.allowTies);
						this.#updateTip();
					}
				}

				#onKeyDown(e) {
					if (this.ui.battleSection.classList.contains("hidden") || ["SELECT", "INPUT", "TEXTAREA"].includes(e.target.tagName)) return;

					const keyMap = {
						ArrowLeft: () => this.ui.leftItem.click(),
						ArrowRight: () => this.ui.rightItem.click(),
						ArrowUp: () => this.state.allowTies && this.ui.tieBtn.click(),
						ArrowDown: () => this.state.allowTies && this.ui.tieBtn.click(),
						z: () => (e.ctrlKey || e.metaKey) && this.ui.undoBtn.click(),
					};
					if (keyMap[e.key]) {
						e.preventDefault();
						keyMap[e.key]();
					}
				}

				#updateTip() {
					this.ui.tip.innerHTML = this.#t(this.state.allowTies ? "keyboardTipWithTies" : "keyboardTipNoTies");
				}

				start() {
					const rawItems = this.ui.itemInput.value.split("\n").map(s => s.trim()).filter(Boolean);
					const items = [...new Set(rawItems)];
					const removed = rawItems.length - items.length;
					if (removed > 0) alert(this.#t("duplicateAlert", { count: removed }));
					if (items.length < 2) return alert(this.#t("alert"));

					this.state.items = items;
					this.state.allowTies = this.ui.allowTies.checked;
					this.#resetBattle();
					this.ui.tieBtns.classList.toggle("hidden", !this.state.allowTies);
					this.#toggleTip(true);
					this.#updateTip();
					this.#show("battleSection");
					this.#next();
				}

				#resetBattle() {
					const n = this.state.items.length;
					this.state.scores = Array(n).fill(PreferenceRank.RATING);
					this.state.progress = 0;
					this.state.history = [];
					this.ui.undoBtn.disabled = true;
					this.state.pairProvider = this.ui.quickRank.checked ? new QuickPairProvider(n) : new FullPairProvider(n);
					this.state.total = this.ui.quickRank.checked ? 0 : this.state.pairProvider.getTotal();
				}

				choose(winner) {
					if (this.state.isChoosing) return;
					this.state.isChoosing = true;

					const p1wins = (winner === "left" && !this.state.isSwapped) || (winner === "right" && this.state.isSwapped);
					const result = winner === "tie" ? 0.5 : (p1wins ? 1 : 0);

					this.state.history.push({ pair: this.state.currentPair, scores: [...this.state.scores], prog: this.state.progress });
					this.state.pairProvider.markAsCompared(this.state.currentPair);
					this.#updateScores(result);

					this.state.progress++;
					this.ui.undoBtn.disabled = false;
					this.#updateProgress();

					this.#clearSelections();
					const btn = winner === "tie" ? this.ui.tieBtn : this.ui[`${winner}Item`];
					btn.classList.add("selected");

					setTimeout(() => {
						this.state.isChoosing = false;
						this.#next();
					}, PreferenceRank.TIMEOUT);
				}

				#updateScores(result) {
					const [i1, i2] = this.state.currentPair;
					const [s1, s2] = [this.state.scores[i1], this.state.scores[i2]];
					const e1 = 1 / (1 + 10 ** ((s2 - s1) / 400));
					this.state.scores[i1] += PreferenceRank.K * (result - e1);
					this.state.scores[i2] += PreferenceRank.K * (e1 - result);
				}

				#next() {
					this.#clearSelections();
					const pair = this.state.pairProvider.getNextPair(this.state);
					if (!pair || (!this.ui.quickRank.checked && this.state.progress >= this.state.total)) return this.showResults();

					this.state.currentPair = pair;
					let [i1, i2] = pair;
					this.state.isSwapped = Math.random() < 0.5;
					if (this.state.isSwapped) [i1, i2] = [i2, i1];

					this.ui.leftItem.textContent = this.state.items[i1];
					this.ui.rightItem.textContent = this.state.items[i2];
					this.#updateProgress();
				}

				#updateProgress() {
					const text = this.ui.quickRank.checked ? `${this.#t("progress")}: ${this.state.progress}` : `${this.#t("progress")}: ${this.state.progress}/${this.state.total}`;
					this.ui.progress.textContent = text;
				}

				#clearSelections() {
					["leftItem", "rightItem", "tieBtn"].forEach(key => this.ui[key].classList.remove("selected"));
				}

				showResults() {
					const sorted = this.state.items.map((item, i) => ({ item, score: this.state.scores[i] })).sort((a, b) => b.score - a.score);
					this.ui.results.innerHTML = `
						<h2>${this.#t("results")}</h2>
						<table>
							<thead><tr><th>${this.#t("rank")}</th><th>${this.#t("item")}</th><th>${this.#t("score")}</th></tr></thead>
							<tbody>${sorted.map(({ item, score }, i) => `<tr><td>${i+1}</td><td>${item}</td><td>${Math.round(score)}</td></tr>`).join("")}</tbody>
						</table>`;
					this.#show("results");
				}

				#show(section) {
					for (const key of ["inputSection", "battleSection", "results"]) {
						this.ui[key].classList.toggle("hidden", key !== section);
					}
					this.ui.restartBtns.classList.toggle("hidden", section !== "results");
				}

				undo() {
					if (this.state.isChoosing || !this.state.history.length) return;
					const last = this.state.history.pop();
					this.state.scores = last.scores;
					this.state.progress = last.prog;
					this.state.pairProvider.unmarkAsCompared(last.pair);
					this.#next();
					this.ui.undoBtn.disabled = !this.state.history.length;
				}

				restart() {
					this.#resetBattle();
					this.#show("battleSection");
					this.#next();
				}

				restartNew() {
					const { lang, theme } = this.state;
					this.state = this.#getInitialState();
					this.state.lang = lang;
					this.state.theme = theme;
					this.ui.langSelect.value = lang;
					this.ui.itemInput.value = "";
					this.ui.allowTies.checked = false;
					this.ui.quickRank.checked = false;
					this.#show("inputSection");
					this.#updateLang();
				}

				#toggleTip(forceHidden) {
					const isHidden = this.ui.tip.classList.toggle("hidden", forceHidden);
					this.ui.tipToggle.textContent = this.#t(isHidden ? "keyboardTipToggleShow" : "keyboardTipToggleHide");
				}
			}

			new PreferenceRank(translations);
		</script>
	</body>
</html>
