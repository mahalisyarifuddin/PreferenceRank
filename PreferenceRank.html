<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>PreferenceRank</title>
<style>
:root {
    --primary: #0070ea;
    --primary-hover: #005bc0;
    --background: #f9f9ff;
    --surface: #fff;
    --text: #414754;
    --border: #c1c6d7;
    --hover: #d7d9e5;
}
@media(prefers-color-scheme:dark) {
    :root:not(.light) {
        --background: #10131b;
        --surface: #181c23;
        --text: #c1c6d7;
        --border: #414754;
        --hover: #10131b;
    }
}
:root.dark {
    --background: #10131b;
    --surface: #181c23;
    --text: #c1c6d7;
    --border: #414754;
    --hover: #10131b;
}
* { box-sizing: border-box; margin: 0; padding: 0 }
body {
    background: var(--background);
    color: var(--text);
    font-family: sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 1rem;
}
.container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    max-width: 720px;
    padding: 2rem;
    width: 100%;
    position: relative;
}
.hidden { display: none !important }
h1, h2, label { margin-bottom: .5rem; display: block }
h1, h2 { margin-top: .5rem }
label { font-weight: 700 }
input, select, textarea, button {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-size: 1rem;
    padding: .5rem;
    width: 100%;
}
textarea { min-height: 80px; resize: vertical }
button { cursor: pointer; transition: background .2s }
.primary { background: var(--primary); border: none; color: #fff }
.primary:hover { background: var(--primary-hover) }
.secondary:hover { background: var(--hover); color: var(--text) }
.selectors { position: absolute; right: 2rem; top: 1rem; display: flex; gap: 8px }
.selectors select { font-size: .9rem; padding: 5px; width: auto }
.checkbox-row { display: flex; align-items: center; gap: 10px; margin: .75rem 0 }
.checkbox-row input { width: auto }
.checkbox-row label { margin: 0 }
#battle, #tieContainer, #restartContainer { display: flex; gap: 1rem; margin-top: 1rem }
#battle button, #tieContainer button, #restartContainer button { flex: 1 }
#battle button, #tieContainer button { font-size: 1.2rem; min-height: 100px }
#progress { font-size: 1.1rem; margin-top: 1rem; text-align: center }
#shortcutTip {
    background: var(--background);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: .85rem;
    line-height: 1.5;
    margin-top: 15px;
    opacity: .9;
    padding: 8px;
    text-align: center;
}
kbd {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    box-shadow: 0 1px 1px #0003;
    display: inline-block;
    font-family: monospace;
    font-size: .9em;
    margin: 0 3px;
    padding: 2px 5px;
}
#cancel, #shortcutToggle {
    background: none;
    border: 1px solid var(--border);
    color: var(--text);
    cursor: pointer;
    display: block;
    font-size: .9rem;
    margin: 1rem auto;
    padding: 5px 15px;
    width: auto;
}
#cancel:hover { background: var(--hover) }
#shortcutToggle { border: none; color: var(--primary); font-size: .85rem; margin-top: 10px; text-decoration: underline }
#results table { border-collapse: collapse; margin-top: 1rem; width: 100% }
#results th, #results td { border: 1px solid var(--border); padding: .5rem; text-align: left }
#results th { background: var(--primary); color: #fff }
.results-header { display: flex; justify-content: center; align-items: center; position: relative; min-height: 40px; margin-bottom: 1rem }
.results-header h2 { margin: 0 }
.results-header #undo { position: absolute; left: 0; top: 50%; transform: translateY(-50%) }
#undo { width: auto }
#undo:disabled { background: var(--hover); cursor: not-allowed }
.selected { background: var(--primary) !important; color: #fff !important }
@media(max-width: 768px) {
    body { padding: .75rem }
    .container { padding: 1.5rem }
    .selectors { position: static; justify-content: flex-end; margin-bottom: .5rem; gap: 4px }
    .selectors select { font-size: .8rem; padding: 4px }
    #battle, #tieContainer, #restartContainer { flex-direction: column }
    #battle button, #tieContainer button { width: 100% }
}
</style>
</head>
<body>
<div class="container">
    <div id="inputSection">
        <div class="selectors">
            <select id="lang"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
            <select id="theme"><option value="auto"></option><option value="light"></option><option value="dark"></option></select>
        </div>
        <h1 id="title"></h1>
        <div class="group">
            <label for="items" id="labelItems"></label>
            <textarea id="items" rows="5" spellcheck="false"></textarea>
        </div>
        <div class="checkbox-row">
            <input type="checkbox" id="allowTies">
            <label for="allowTies" id="labelTies"></label>
        </div>
        <div class="checkbox-row">
            <input type="checkbox" id="quickRank">
            <label for="quickRank" id="labelQuick"></label>
        </div>
        <button id="start" class="primary"></button>
    </div>
    <button id="undo" class="secondary hidden" disabled></button>
    <div id="battleSection" class="hidden">
        <div id="battle">
            <button id="left" class="secondary"></button>
            <button id="right" class="secondary"></button>
        </div>
        <div id="tieContainer" class="hidden">
            <button id="tie" class="secondary"></button>
        </div>
        <div id="progress"></div>
        <button id="cancel"></button>
        <button id="shortcutToggle"></button>
        <div id="shortcutTip" class="hidden"></div>
    </div>
    <div id="results" class="hidden"></div>
    <div id="restartContainer" class="hidden">
        <button id="restartBattle" class="primary"></button>
        <button id="restartNew" class="primary"></button>
    </div>
</div>
<script>
const TEXT = {
    title: ['PreferenceRank', 'PreferenceRank'],
    auto: ['Auto Theme', 'Tema Otomatis'],
    light: ['Light', 'Terang'],
    dark: ['Dark', 'Gelap'],
    labelItems: ['Enter items, one per line:', 'Masukkan pilihan, satu per baris:'],
    labelTies: ['Allow Ties', 'Izinkan Seri'],
    labelQuick: ['Use Quick Rank (fewer comparisons)', 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)'],
    alert: ['Please enter at least two items.', 'Harap masukkan setidaknya dua pilihan.'],
    duplicate: ['{c} duplicate item(s) removed.', '{c} item duplikat dihapus.'],
    start: ['Start Ranking', 'Mulai Peringkat'],
    cancel: ['Cancel', 'Batal'],
    tie: ['It\'s a Tie', 'Seri'],
    undo: ['Undo', 'Urungkan'],
    progress: ['Progress', 'Kemajuan'],
    toggleShow: ['Show keyboard shortcuts', 'Tampilkan pintasan papan ketik'],
    toggleHide: ['Hide keyboard shortcuts', 'Sembunyikan pintasan papan ketik'],
    tipTie: ['Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>↑</kbd>/<kbd>↓</kbd> Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo', 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>↑</kbd>/<kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan'],
    tipNoTie: ['Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo', 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan'],
    resultsTitle: ['Results', 'Hasil'],
    rank: ['Rank', 'Peringkat'],
    item: ['Item', 'Nama'],
    score: ['Score', 'Skor'],
    restartBattle: ['Restart Battle', 'Mulai Ulang Pertarungan'],
    restartNew: ['Start with New Items', 'Mulai dengan Pilihan Baru']
};

const $ = id => document.getElementById(id);
const esc = t => Object.assign(document.createElement('p'), { textContent: t }).innerHTML;

class PairProvider {
    constructor(n) {
        this.n = n;
        this.compared = new Set();
    }
    key([a, b]) { return a < b ? a + '-' + b : b + '-' + a; }
    mark(pair) { this.compared.add(this.key(pair)); }
    unmark(pair) { this.compared.delete(this.key(pair)); }
    getResults(items, scores) {
        return items.map((t, i) => ({ t, s: scores[i] })).sort((a, b) => b.s - a.s);
    }
    getProgress(step) { return step; }
}

class FullPairProvider extends PairProvider {
    constructor(n) {
        super(n);
        this.pairs = [];
        for (let i = 0; i < n - 1; i++)
            for (let j = i + 1; j < n; j++)
                this.pairs.push([i, j]);
        for (let i = this.pairs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.pairs[i], this.pairs[j]] = [this.pairs[j], this.pairs[i]];
        }
    }
    next(state) { return this.pairs[state.step]; }
    getProgress(step) { return `${step}/${this.pairs.length}`; }
}

class QuickPairProvider extends PairProvider {
    constructor(n) {
        super(n);
        this.stack = [{ stage: 0, items: [...Array(n).keys()] }];
        this.history = [];
        this.pending = null;
        this.prevScores = null;
        this.final = null;
        this.refinePass = 0;
        this.refineIdx = 0;
        this.refineSwapped = false;
    }
    snapshot() {
        return JSON.stringify({
            stack: this.stack, pending: this.pending, prevScores: this.prevScores,
            compared: [...this.compared], final: this.final,
            refinePass: this.refinePass, refineIdx: this.refineIdx, refineSwapped: this.refineSwapped
        });
    }
    restore(json) {
        Object.assign(this, JSON.parse(json));
        this.compared = new Set(this.compared);
    }
    unmark(pair) {
        if (this.pending && this.history.length) this.history.pop();
        if (this.history.length) {
            this.restore(this.history[this.history.length - 1]);
            this.pending = pair;
        }
        super.unmark(pair);
    }
    next(state) {
        if (!this.prevScores) this.prevScores = [...state.scores];
        if (this.pending) {
            const [a, b] = this.pending;
            const change = state.scores[a] - this.prevScores[a];
            const expected = 1 / (1 + 10 ** ((this.prevScores[b] - this.prevScores[a]) / 400));
            const result = (change / 32) + expected;
            const winner = Math.abs(result - 0.5) < 0.01 ? a : result > 0.75 ? a : b;

            const last = this.stack[this.stack.length - 1];
            if (this.stack.length) last.mergeResult.push((winner === a ? last.left : last.right).shift());

            if (this.final && winner === b) {
                [this.final[this.refineIdx], this.final[this.refineIdx + 1]] = [this.final[this.refineIdx + 1], this.final[this.refineIdx]];
                this.refineSwapped = true;
            }
            if (this.final) this.refineIdx++;

            this.pending = null;
            this.prevScores = [...state.scores];
        }

        while (this.stack.length) {
            const frame = this.stack[this.stack.length - 1];
            if (frame.stage === 0) {
                if (frame.items.length <= 1) { this.pop(frame.items); continue; }
                const mid = frame.items.length >> 1;
                frame.stage = 1;
                frame.leftItems = frame.items.slice(0, mid);
                frame.rightItems = frame.items.slice(mid);
                this.stack.push({ stage: 0, items: frame.leftItems });
                continue;
            }
            if (frame.stage === 1) {
                frame.stage = 2;
                this.stack.push({ stage: 0, items: frame.rightItems });
                continue;
            }
            if (frame.stage === 2) {
                if (!frame.mergeResult) {
                    frame.mergeResult = [];
                    frame.left = [...frame.leftResult];
                    frame.right = [...frame.rightResult];
                }
                while (frame.left.length && frame.right.length) {
                    const pair = [frame.left[0], frame.right[0]];
                    this.history.push(this.snapshot());
                    this.pending = pair;
                    return pair;
                }
                frame.mergeResult.push(...frame.left, ...frame.right);
                this.pop(frame.mergeResult);
                continue;
            }
        }

        if (this.final) {
            while (true) {
                if (this.refinePass >= 3) return null;
                if (this.refineIdx >= this.final.length - 1) {
                    if (!this.refineSwapped) return null;
                    this.refinePass++; this.refineIdx = 0; this.refineSwapped = false;
                    continue;
                }
                const [a, b] = [this.final[this.refineIdx], this.final[this.refineIdx + 1]];
                if (this.compared.has(this.key([a, b]))) { this.refineIdx++; continue; }
                this.history.push(this.snapshot());
                this.pending = [a, b];
                return [a, b];
            }
        }
        return null;
    }
    pop(result) {
        this.stack.pop();
        if (this.stack.length) {
            const p = this.stack[this.stack.length - 1];
            p.stage === 1 ? p.leftResult = result : p.rightResult = result;
        } else this.final = result;
    }
    getResults(items, scores) {
        if (!this.final) return super.getResults(items, scores);
        const sortedScores = [...scores].sort((a, b) => b - a);
        return this.final.map((idx, k) => ({ t: items[idx], s: sortedScores[k] }));
    }
}

class PreferenceRank {
    constructor() {
        this.items = []; this.scores = []; this.pair = null; this.swapped = false;
        this.step = 0; this.ties = false; this.history = []; this.kbEnabled = false;
        this.busy = false; this.swaps = new Map();
        this.langIdx = navigator.language.startsWith('id') ? 1 : 0;
        this.init();
    }
    str(key) { return TEXT[key][this.langIdx]; }
    init() {
        const bind = (id, fn) => $(id).onclick = fn;
        bind('start', () => this.start());
        bind('cancel', () => this.show('inputSection'));
        bind('left', () => this.choose('left'));
        bind('right', () => this.choose('right'));
        bind('tie', () => this.choose('tie'));
        bind('restartBattle', () => this.restart());
        bind('restartNew', () => this.reset());
        bind('undo', () => this.undo());
        bind('shortcutToggle', () => this.toggleHelp());
        $('lang').onchange = e => { this.langIdx = e.target.value === 'id' ? 1 : 0; this.updateText(); };
        $('theme').onchange = e => this.setTheme(e.target.value);
        $('allowTies').onchange = e => this.setTies(e.target.checked);
        document.onkeydown = e => this.handleKey(e);
        this.setTheme('auto');
        this.updateText();
    }
    setTheme(theme) {
        document.documentElement.className = theme === 'auto' ? '' : theme;
        $('theme').value = theme;
    }
    updateText() {
        $('lang').value = this.langIdx ? 'id' : 'en';
        const setText = (id, key) => $(id).textContent = this.str(key);
        ['title', 'labelItems', 'labelTies', 'labelQuick', 'start', 'cancel', 'tie', 'undo', 'restartBattle', 'restartNew', 'shortcutToggle'].forEach(k => {
            const id = k.startsWith('label') ? k : (k === 'shortcutToggle' ? 'shortcutToggle' : (k === 'title' ? 'title' : k));
            setText(id, k);
        });
        $('theme').options[0].textContent = this.str('auto');
        $('theme').options[1].textContent = this.str('light');
        $('theme').options[2].textContent = this.str('dark');
        this.updateHelp();
        this.updateProgress();
        if (!$('results').classList.contains('hidden')) this.renderResults();
    }
    setTies(enabled) {
        this.ties = enabled;
        if (!$('battleSection').classList.contains('hidden')) $('tieContainer').classList.toggle('hidden', !enabled);
        this.updateHelp();
    }
    updateHelp() {
        const hidden = $('shortcutTip').classList.contains('hidden');
        $('shortcutToggle').textContent = this.str(hidden ? 'toggleShow' : 'toggleHide');
        $('shortcutTip').innerHTML = this.str(this.ties ? 'tipTie' : 'tipNoTie');
    }
    toggleHelp() { $('shortcutTip').classList.toggle('hidden'); this.updateHelp(); }
    start() {
        const raw = $('items').value.split('\n').map(l => l.trim()).filter(Boolean);
        const unique = [...new Set(raw)];
        if (raw.length > unique.length) alert(this.str('duplicate').replace('{c}', raw.length - unique.length));
        if (unique.length < 2) return alert(this.str('alert'));

        this.items = unique;
        this.ties = $('allowTies').checked;
        this.scores = Array(unique.length).fill(1000);
        this.step = 0;
        this.history = [];
        this.swaps = new Map();
        $('undo').disabled = true;
        this.provider = $('quickRank').checked ? new QuickPairProvider(unique.length) : new FullPairProvider(unique.length);

        $('tieContainer').classList.toggle('hidden', !this.ties);
        this.updateHelp();
        this.show('battleSection');
        this.next();
    }
    choose(winner) {
        if (this.busy || $('battleSection').classList.contains('hidden')) return;
        this.busy = true;
        this.history.push({ pair: this.pair, scores: [...this.scores], step: this.step, swapped: this.swapped });
        this.provider.mark(this.pair);

        const [a, b] = this.pair;
        const isLeftWinner = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
        const result = winner === 'tie' ? 0.5 : isLeftWinner ? 1 : 0;
        const expected = 1 / (1 + 10 ** ((this.scores[b] - this.scores[a]) / 400));

        this.scores[a] += 32 * (result - expected);
        this.scores[b] += 32 * (expected - result);
        this.step++;
        $('undo').disabled = false;
        this.updateProgress();
        this.clearSelections();
        (winner === 'tie' ? $('tie') : $(winner)).classList.add('selected');

        setTimeout(() => { this.busy = false; this.next(); }, 300);
    }
    next() {
        this.clearSelections();
        const nextPair = this.provider.next(this);
        if (!nextPair) return this.renderResults();

        this.pair = nextPair;
        const key = this.provider.key(nextPair);
        if (!this.swaps.has(key)) this.swaps.set(key, Math.random() < 0.5);
        this.swapped = this.swaps.get(key);

        let [a, b] = nextPair;
        if (this.swapped) [a, b] = [b, a];
        $('left').textContent = this.items[a];
        $('right').textContent = this.items[b];
        this.updateProgress();
    }
    updateProgress() {
        $('progress').textContent = `${this.str('progress')}: ${this.provider ? this.provider.getProgress(this.step) : '0'}`;
    }
    clearSelections() { ['left', 'right', 'tie'].forEach(id => $(id).classList.remove('selected')); }
    renderResults() {
        const results = this.provider.getResults(this.items, this.scores);
        $('results').innerHTML = `<div class="results-header"><h2>${this.str('resultsTitle')}</h2></div><table><thead><tr><th style="width:20%">${this.str('rank')}</th><th style="width:60%">${this.str('item')}</th><th style="width:20%">${this.str('score')}</th></tr></thead><tbody>${results.map(x => `<tr><td>${results.findIndex(y => Math.round(y.s) === Math.round(x.s)) + 1}</td><td>${esc(x.t)}</td><td>${Math.round(x.s)}</td></tr>`).join('')}</tbody></table>`;
        this.show('results');
    }
    show(section) {
        ['inputSection', 'battleSection', 'results'].forEach(id => $(id).classList.toggle('hidden', id !== section));
        $('restartContainer').classList.toggle('hidden', section !== 'results');
        $('undo').classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
        this.kbEnabled = section === 'battleSection' || section === 'results';
        if (section === 'battleSection') $('undo').parentNode.insertBefore($('undo'), $('battleSection'));
        else if (section === 'results') $('results').firstElementChild.prepend($('undo'));
    }
    undo() {
        if (this.busy || !this.history.length) return;
        const last = this.history.pop();
        Object.assign(this, { scores: last.scores, step: last.step, pair: last.pair, swapped: last.swapped });
        this.provider.unmark(last.pair);
        let [a, b] = last.pair;
        if (this.swapped) [a, b] = [b, a];
        $('left').textContent = this.items[a];
        $('right').textContent = this.items[b];
        this.updateProgress();
        this.show('battleSection');
        $('undo').disabled = !this.history.length;
    }
    restart() { this.start(); }
    reset() {
        Object.assign(this, { items: [], scores: [], pair: null, swapped: false, step: 0, ties: false, history: [], kbEnabled: false, busy: false, provider: null, swaps: new Map() });
        $('items').value = ''; $('allowTies').checked = false; $('quickRank').checked = false;
        this.show('inputSection');
        this.updateHelp();
        this.updateProgress();
    }
    handleKey(e) {
        if (!this.kbEnabled || ['SELECT', 'INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
        const key = e.key, map = { ArrowLeft: 'left', ArrowRight: 'right', ArrowUp: 'tie', ArrowDown: 'tie', z: 'undo', Z: 'undo' };
        if (!map[key]) return;

        const isUndo = key.toLowerCase() === 'z';
        if (isUndo && !e.ctrlKey && !e.metaKey) return;
        if (isUndo && e.shiftKey) return;
        if (['ArrowUp', 'ArrowDown'].includes(key) && !this.ties) return;
        if (!isUndo && $('battleSection').classList.contains('hidden')) return;

        e.preventDefault();
        $(map[key]).click();
    }
}
new PreferenceRank();
</script>
</body>
</html>
