<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>PreferenceRank</title>
	<style>
	  :root {
		--primary: #0070ea;
		--primary-hover: #005bc0;
		--space-xs: 0.5rem;
		--space-sm: 1rem;
		--space-md: 1.5rem;
		--space-lg: 2rem;
		--radius-sm: 4px;
		--radius: 8px;
		--bg: #f9f9ff;
		--bg-container: #ffffff;
		--text: #414754;
		--border: #c1c6d7;
		--btn-hover: #d7d9e5;
	  }
	  @media (prefers-color-scheme: dark) {
		:root:not(.light-theme):not(.dark-theme) {
		  --bg: #10131b;
		  --bg-container: #181c23;
		  --text: #c1c6d7;
		  --border: #414754;
		  --btn-hover: #10131b;
		}
	  }
	  :root.dark-theme {
		--bg: #10131b;
		--bg-container: #181c23;
		--text: #c1c6d7;
		--border: #414754;
		--btn-hover: #10131b;
	  }

	  html {
		box-sizing: border-box;
	  }
	  *,
	  *::before,
	  *::after {
		margin: 0;
		padding: 0;
		box-sizing: inherit;
	  }

	  body {
		font-family: sans-serif;
		background-color: var(--bg);
		color: var(--text);
		min-height: 100vh;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: var(--space-sm);
	  }

	  .container {
		background-color: var(--bg-container);
		color: var(--text);
		width: 100%;
		max-width: 720px;
		padding: var(--space-lg);
		border-radius: var(--radius);
		box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		position: relative;
	  }

	  .container:has(#inputSection:not(.hidden)) {
		padding-top: 3rem;
	  }

	  .hidden {
		display: none !important;
	  }

	  h1,
	  h2 {
		margin: var(--space-xs) 0;
		text-align: left;
	  }

	  .form-group {
		margin-bottom: var(--space-sm);
	  }

	  label {
		display: block;
		margin-bottom: var(--space-xs);
		font-weight: bold;
	  }

	  input,
	  select,
	  textarea,
	  button {
		width: 100%;
		padding: var(--space-xs);
		font-size: 1rem;
		border: 1px solid var(--border);
		border-radius: var(--radius-sm);
		background-color: var(--bg-container);
		color: var(--text);
	  }

	  textarea {
		resize: vertical;
		min-height: 80px;
	  }

	  button {
		cursor: pointer;
		transition: background-color 0.2s ease;
	  }

	  .btn-primary {
		background-color: var(--primary);
		color: #fff;
		border: none;
	  }
	  .btn-primary:hover {
		background-color: var(--primary-hover);
	  }

	  .btn-secondary {
		background-color: var(--bg-container);
		color: var(--text);
	  }
	  .btn-secondary:hover {
		background-color: var(--btn-hover);
	  }

	  #battle,
	  #restartButtons,
	  #tieButtons {
		display: flex;
		gap: var(--space-sm);
		margin-top: var(--space-sm);
	  }

	  #tieButtons.hidden {
		display: none !important;
	  }

	  #battle button,
	  #tieButtons button {
		flex: 1;
		min-width: 200px;
		min-height: 100px;
		font-size: 1.2rem;
	  }

	  #restartButtons button {
		flex: 1;
		font-size: 1rem;
	  }

	  #progress {
		margin-top: var(--space-sm);
		font-size: 1.1rem;
		text-align: center;
	  }

	  #keyboardTip {
		margin-top: 15px;
		font-size: 0.85rem;
		text-align: center;
		opacity: 0.9;
		line-height: 1.5;
		padding: 8px;
		border: 1px solid var(--border);
		border-radius: var(--radius-sm);
		background-color: var(--bg);
	  }

	  #keyboardTip kbd {
		background-color: var(--bg-container);
		border: 1px solid var(--border);
		border-radius: 3px;
		box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
		padding: 2px 5px;
		font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono",
		  monospace;
		font-size: 0.9em;
		display: inline-block;
		margin: 0 3px;
	  }

	  #keyboardTipToggle {
		display: block;
		text-align: center;
		margin: 10px auto 0;
		font-size: 0.85rem;
		cursor: pointer;
		text-decoration: underline;
		color: var(--primary);
		background: none;
		border: none;
		width: auto;
		padding: 0;
	  }

	  .selectors-container {
		position: absolute;
		right: var(--space-lg);
		top: var(--space-sm);
		display: flex;
		gap: 8px;
	  }

	  .selector {
		width: auto;
		padding: 5px;
		font-size: 0.9rem;
	  }

	  .checkbox-container {
		display: flex;
		align-items: center;
		margin-bottom: var(--space-sm);
		gap: 10px;
	  }
	  .checkbox-container input[type="checkbox"] {
		width: auto;
	  }
	  .checkbox-container label {
		margin-bottom: 0;
	  }

	  #results table {
		width: 100%;
		border-collapse: collapse;
		margin-top: var(--space-sm);
	  }
	  #results th,
	  #results td {
		border: 1px solid var(--border);
		padding: var(--space-xs);
		text-align: left;
	  }
	  #results th {
		background-color: var(--primary);
		color: #fff;
	  }

	  #undoButton {
		margin-top: var(--space-sm);
		font-size: 1rem;
		width: auto;
	  }
	  #undoButton:disabled {
		background-color: var(--btn-hover);
		cursor: not-allowed;
	  }

	  .selected {
		background-color: var(--primary) !important;
		color: #fff !important;
	  }

	  @media (max-width: 768px) {
		.container {
		  padding: var(--space-md);
		}
		.container:has(#inputSection:not(.hidden)) {
		  padding-top: calc(var(--space-sm) + var(--space-md) + var(--space-xs));
		}
		.selectors-container {
		  top: var(--space-xs);
		  right: var(--space-xs);
		  gap: 4px;
		}
		.selector {
		  font-size: 0.8rem;
		  padding: 4px;
		}
		#battle,
		#tieButtons,
		#restartButtons {
		  flex-direction: column;
		}
		#battle button,
		#tieButtons button {
		  width: 100%;
		  min-width: auto;
		}
	  }
	</style>
  </head>
  <body>
	<div class="container">
	  <div id="inputSection">
		<h1 id="title"></h1>

		<div class="selectors-container">
		  <select id="languageSelect" class="selector" aria-label="Language">
			<option value="en">English</option>
			<option value="id">Bahasa Indonesia</option>
		  </select>
		  <select id="themeSelect" class="selector" aria-label="Theme">
			<option value="auto" id="autoTheme"></option>
			<option value="light" id="lightTheme"></option>
			<option value="dark" id="darkTheme"></option>
		  </select>
		</div>

		<div class="form-group">
		  <label for="itemInput" id="itemInputLabel"></label>
		  <textarea id="itemInput" rows="5" spellcheck="false"></textarea>
		</div>

		<div class="checkbox-container">
		  <input type="checkbox" id="allowTies" />
		  <label for="allowTies" id="allowTiesLabel"></label>
		</div>

		<div class="checkbox-container">
		  <input type="checkbox" id="quickRankMode" />
		  <label for="quickRankMode" id="quickRankModeLabel"></label>
		</div>

		<button id="startButton" class="btn-primary"></button>
	  </div>

	  <div id="battleSection" class="hidden" aria-live="polite">
		<button id="undoButton" class="btn-secondary" disabled></button>

		<div id="battle">
		  <button id="leftItem" class="btn-secondary" aria-label="Left choice"></button>
		  <button id="rightItem" class="btn-secondary" aria-label="Right choice"></button>
		</div>

		<div id="tieButtons" class="hidden">
		  <button id="likeBothButton" class="btn-secondary"></button>
		  <button id="dislikeBothButton" class="btn-secondary"></button>
		</div>

		<div id="progress" aria-live="polite"></div>
		<button id="keyboardTipToggle"></button>
		<div id="keyboardTip" class="hidden"></div>
	  </div>

	  <div id="results" class="hidden"></div>

	  <div id="restartButtons" class="hidden">
		<button id="restartBattleButton" class="btn-primary"></button>
		<button id="restartNewItemsButton" class="btn-primary"></button>
	  </div>
	</div>

	<script>
	  (() => {
		const $ = (id) => document.getElementById(id);

		class PreferenceRank {
		  constructor() {
			this.INITIAL_RATING = 1000;
			this.K_FACTOR = 32;

			this.el = {};
			[
			  "languageSelect",
			  "themeSelect",
			  "allowTies",
			  "quickRankMode",
			  "startButton",
			  "leftItem",
			  "rightItem",
			  "likeBothButton",
			  "dislikeBothButton",
			  "restartBattleButton",
			  "restartNewItemsButton",
			  "undoButton",
			  "keyboardTipToggle",
			  "inputSection",
			  "battleSection",
			  "results",
			  "restartButtons",
			  "tieButtons",
			  "keyboardTip",
			  "progress",
			  "itemInput",
			  "title",
			  "autoTheme",
			  "lightTheme",
			  "darkTheme",
			  "itemInputLabel",
			  "allowTiesLabel",
			  "quickRankModeLabel",
			].forEach((id) => (this.el[id] = $(id)));

			this.state = {
			  items: [],
			  scores: [],
			  pairs: [],
			  i: 0,
			  progress: 0,
			  total: 0,
			  allowTies: false,
			  language: navigator.language?.startsWith("id") ? "id" : "en",
			  theme: "auto",
			  history: [],
			  keyboardEnabled: false,
			};

			this.translations = {
			  en: {
				title: "PreferenceRank",
				autoTheme: "Auto Theme",
				lightTheme: "Light",
				darkTheme: "Dark",
				itemInputLabel: "Enter items, one per line:",
				allowTiesLabel: "Allow Ties",
				quickRankModeLabel: "Use Quick Rank (fewer comparisons)",
				alert: "Please enter at least two items.",
				startButton: "Start Ranking",
				likeBothButton: "Like Both",
				dislikeBothButton: "Dislike Both",
				undoButton: "Undo",
				progress: "Progress",
				keyboardTipToggle: "Show keyboard shortcuts",
				keyboardTipHide: "Hide keyboard shortcuts",
				keyboardTipWithTies:
				  'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> Like both<br><kbd>↓</kbd> Dislike both<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
				keyboardTipNoTies:
				  'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
				results: "Results",
				rank: "Rank",
				item: "Item",
				score: "Score",
				restartBattleButton: "Restart Battle",
				restartNewItemsButton: "Start with New Items",
			  },
			  id: {
				title: "PreferenceRank",
				autoTheme: "Tema Otomatis",
				lightTheme: "Terang",
				darkTheme: "Gelap",
				itemInputLabel: "Masukkan pilihan, satu per baris:",
				allowTiesLabel: "Izinkan Seri",
				quickRankModeLabel:
				  "Gunakan Peringkat Cepat (lebih sedikit perbandingan)",
				alert: "Harap masukkan setidaknya dua pilihan.",
				startButton: "Mulai Peringkat",
				likeBothButton: "Suka Keduanya",
				dislikeBothButton: "Tidak Suka Keduanya",
				undoButton: "Urungkan",
				progress: "Kemajuan",
				keyboardTipToggle: "Tampilkan pintasan papan ketik",
				keyboardTipHide: "Sembunyikan pintasan papan ketik",
				keyboardTipWithTies:
				  "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> Suka keduanya<br><kbd>↓</kbd> Tidak suka keduanya<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
				keyboardTipNoTies:
				  "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
				results: "Hasil",
				rank: "Peringkat",
				item: "Nama",
				score: "Skor",
				restartBattleButton: "Mulai Ulang Pertarungan",
				restartNewItemsButton: "Mulai dengan Pilihan Baru",
			  },
			};

			this.init();
		  }

		  t() {
			return this.translations[this.state.language];
		  }

		  init() {
			this.setupEventListeners();
			this.el.languageSelect.value = this.state.language;
			this.applyTheme();
			this.updateLanguage();
		  }

		  setupEventListeners() {
			const on = (el, ev, fn) => el.addEventListener(ev, fn);

			on(this.el.languageSelect, "change", () => this.updateLanguage());
			on(this.el.themeSelect, "change", () => {
			  this.state.theme = this.el.themeSelect.value;
			  this.applyTheme();
			});
			on(this.el.allowTies, "change", () => {
			  this.state.allowTies = this.el.allowTies.checked;
			  if (!this.el.battleSection.classList.contains("hidden")) {
				this.el.tieButtons.classList.toggle("hidden", !this.state.allowTies);
				this.updateKeyboardTipContent();
			  }
			});
			on(this.el.startButton, "click", () => this.startRank());
			on(this.el.leftItem, "click", (e) => this.choose("left", e));
			on(this.el.rightItem, "click", (e) => this.choose("right", e));
			on(this.el.likeBothButton, "click", (e) => this.choose("tie", e));
			on(this.el.dislikeBothButton, "click", (e) => this.choose("tie", e));
			on(this.el.restartBattleButton, "click", () => this.restartBattle());
			on(this.el.restartNewItemsButton, "click", () => this.restartNewItems());
			on(this.el.undoButton, "click", () => this.undo());
			on(this.el.keyboardTipToggle, "click", () => this.toggleKeyboardTip());

			document.addEventListener("keydown", (e) => {
			  if (
				!this.state.keyboardEnabled ||
				["SELECT", "INPUT", "TEXTAREA"].includes(
				  document.activeElement.tagName
				)
			  )
				return;

			  const map = {
				ArrowLeft: () => this.el.leftItem.click(),
				ArrowRight: () => this.el.rightItem.click(),
				ArrowUp: () => this.state.allowTies && this.el.likeBothButton.click(),
				ArrowDown: () =>
				  this.state.allowTies && this.el.dislikeBothButton.click(),
				z: () =>
				  (e.ctrlKey || e.metaKey) &&
				  !this.el.undoButton.disabled &&
				  this.el.undoButton.click(),
			  };

			  if (map[e.key]) {
				e.preventDefault();
				map[e.key]();
			  }
			});
		  }

		  applyTheme() {
			const html = document.documentElement;
			html.classList.remove("light-theme", "dark-theme");
			if (this.state.theme === "light") html.classList.add("light-theme");
			else if (this.state.theme === "dark") html.classList.add("dark-theme");
		  }

		  updateLanguage() {
			this.state.language = this.el.languageSelect.value;
			const t = this.t();

			[
			  "title",
			  "autoTheme",
			  "lightTheme",
			  "darkTheme",
			  "itemInputLabel",
			  "allowTiesLabel",
			  "quickRankModeLabel",
			  "startButton",
			  "likeBothButton",
			  "dislikeBothButton",
			  "undoButton",
			  "restartBattleButton",
			  "restartNewItemsButton",
			].forEach((key) => {
			  const el = this.el[key];
			  if (el) el.textContent = t[key];
			});

			this.el.keyboardTipToggle.textContent = this.el.keyboardTip.classList.contains(
			  "hidden"
			)
			  ? t.keyboardTipToggle
			  : t.keyboardTipHide;

			this.updateKeyboardTipContent();
			this.updateProgress();
			if (!this.el.results.classList.contains("hidden")) this.showResults();
		  }

		  updateKeyboardTipContent() {
			const t = this.t();
			this.el.keyboardTip.innerHTML = t[
			  this.state.allowTies ? "keyboardTipWithTies" : "keyboardTipNoTies"
			];
		  }

		  startRank() {
			const items = this.el.itemInput.value
			  .split("\n")
			  .map((s) => s.trim())
			  .filter(Boolean);

			if (items.length < 2) return alert(this.t().alert);

			const n = items.length;
			const quick = this.el.quickRankMode.checked;
			const pairs = quick && n > 4 ? this.generateQuickRankPairs(n) : this.generatePairs(n);
			this.shuffle(pairs);

			this.state.items = items;
			this.state.scores = Array(n).fill(this.INITIAL_RATING);
			this.state.pairs = pairs;
			this.state.i = 0;
			this.state.progress = 0;
			this.state.total = pairs.length;
			this.state.allowTies = this.el.allowTies.checked;
			this.state.history = [];

			this.el.undoButton.disabled = true;
			this.el.tieButtons.classList.toggle("hidden", !this.state.allowTies);
			this.el.keyboardTip.classList.add("hidden");
			this.el.keyboardTipToggle.textContent = this.t().keyboardTipToggle;
			this.updateKeyboardTipContent();

			this.showSection("battleSection");
			this.nextBattle();
		  }

		  generatePairs(n) {
			const pairs = [];
			for (let i = 0; i < n - 1; i++) for (let j = i + 1; j < n; j++) pairs.push([i, j]);
			return pairs;
		  }

		  generateQuickRankPairs(n) {
			if (n <= 4) return this.generatePairs(n);

			const set = new Set(); 
			const add = (a, b) => {
			  const i = Math.min(a, b),
				j = Math.max(a, b);
			  set.add(i * n + j);
			};

			for (let i = 0; i < n - 1; i++) add(i, i + 1);
			const half = Math.floor(n / 2);
			for (let i = 0; i < n - half; i++) add(i, i + half);

			const target = Math.max(0, Math.floor(n * 0.75) - set.size);
			if (target > 0) {
			  const missing = [];
			  for (let i = 0; i < n - 1; i++) {
				for (let j = i + 1; j < n; j++) {
				  const id = i * n + j;
				  if (!set.has(id)) missing.push(id);
				}
			  }
			  this.shuffle(missing);
			  for (let k = 0; k < Math.min(target, missing.length); k++) set.add(missing[k]);
			}

			return Array.from(set, (id) => [Math.floor(id / n), id % n]);
		  }

		  shuffle(a) {
			for (let i = a.length - 1; i > 0; i--) {
			  const j = (Math.random() * (i + 1)) | 0;
			  [a[i], a[j]] = [a[j], a[i]];
			}
			return a;
		  }

		  choose(winner, e) {
			const [li, ri] = this.state.pairs[this.state.i];
			const result = { left: 1, right: 0, tie: 0.5 }[winner];

			this.state.history.push({
			  li,
			  ri,
			  lScore: this.state.scores[li],
			  rScore: this.state.scores[ri],
			  iBefore: this.state.i,
			  progressBefore: this.state.progress,
			});

			const sl = this.state.scores[li];
			const sr = this.state.scores[ri];
			const expectedL = 1 / (1 + 10 ** ((sr - sl) / 400));
			this.state.scores[li] = sl + this.K_FACTOR * (result - expectedL);
			this.state.scores[ri] = sr + this.K_FACTOR * (expectedL - result);

			this.state.i++;
			this.state.progress++;
			this.el.undoButton.disabled = false;
			this.updateProgress();

			this.clearSelections();
			(winner === "tie" ? e.target : this.el[winner + "Item"]).classList.add("selected");
			setTimeout(() => this.nextBattle(), 300);
		  }

		  nextBattle() {
			if (this.state.i >= this.state.total) return this.showResults();
			const [li, ri] = this.state.pairs[this.state.i];
			this.el.leftItem.textContent = this.state.items[li];
			this.el.rightItem.textContent = this.state.items[ri];
			this.updateProgress();
			this.clearSelections();
		  }

		  updateProgress() {
			this.el.progress.textContent = `${this.t().progress}: ${this.state.progress}/${this.state.total}`;
		  }

		  clearSelections() {
			["leftItem", "rightItem", "likeBothButton", "dislikeBothButton"].forEach((id) =>
			  this.el[id].classList.remove("selected")
			);
		  }

		  showResults() {
			const t = this.t();
			const idx = this.state.scores
			  .map((_, i) => i)
			  .sort((a, b) => this.state.scores[b] - this.state.scores[a]);

			const rows = idx
			  .map(
				(i, rank) =>
				  `<tr><td>${rank + 1}</td><td>${this.state.items[i]}</td><td>${Math.round(
					this.state.scores[i]
				  )}</td></tr>`
			  )
			  .join("");

			this.el.results.innerHTML = `
			  <h2>${t.results}</h2>
			  <table>
				<thead>
				  <tr>
					<th style="width:20%">${t.rank}</th>
					<th style="width:60%">${t.item}</th>
					<th style="width:20%">${t.score}</th>
				  </tr>
				</thead>
				<tbody>${rows}</tbody>
			  </table>
			`;

			this.showSection("results");
		  }

		  showSection(id) {
			["inputSection", "battleSection", "results"].forEach((sec) => {
			  this.el[sec].classList.toggle("hidden", sec !== id);
			});
			this.el.restartButtons.classList.toggle("hidden", id !== "results");
			this.state.keyboardEnabled = id === "battleSection";
		  }

		  undo() {
			if (!this.state.history.length) return;
			const last = this.state.history.pop();

			this.state.scores[last.li] = last.lScore;
			this.state.scores[last.ri] = last.rScore;
			this.state.i = last.iBefore;
			this.state.progress = last.progressBefore;

			const [li, ri] = this.state.pairs[this.state.i];
			this.el.leftItem.textContent = this.state.items[li];
			this.el.rightItem.textContent = this.state.items[ri];

			this.updateProgress();
			this.clearSelections();
			this.el.undoButton.disabled = this.state.history.length === 0;
		  }

		  restartBattle() {
			const n = this.state.items.length;
			const quick = this.el.quickRankMode.checked;
			const pairs = quick && n > 4 ? this.generateQuickRankPairs(n) : this.generatePairs(n);
			this.shuffle(pairs);

			this.state.pairs = pairs;
			this.state.scores = Array(n).fill(this.INITIAL_RATING);
			this.state.i = 0;
			this.state.progress = 0;
			this.state.total = pairs.length;
			this.state.history = [];
			this.el.undoButton.disabled = true;

			this.showSection("battleSection");
			this.nextBattle();
		  }

		  restartNewItems() {
			this.state.items = [];
			this.state.scores = [];
			this.state.pairs = [];
			this.state.i = 0;
			this.state.progress = 0;
			this.state.total = 0;
			this.state.history = [];
			this.el.undoButton.disabled = true;
			this.el.itemInput.value = "";
			this.showSection("inputSection");
		  }

		  toggleKeyboardTip() {
			const visible = this.el.keyboardTip.classList.toggle("hidden");
			this.el.keyboardTipToggle.textContent = visible
			  ? this.t().keyboardTipToggle
			  : this.t().keyboardTipHide;
		  }
		}

		document.addEventListener("DOMContentLoaded", () => new PreferenceRank());
	  })();
	</script>
  </body>
</html>
