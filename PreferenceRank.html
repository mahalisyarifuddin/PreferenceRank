<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1.0">
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--background: #f9f9ff;
				--surface: #fff;
				--text: #414754;
				--border: #c1c6d7;
				--hover: #d7d9e5;
			}

			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--background: #10131b;
					--surface: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--hover: #10131b;
				}
			}

			:root.dark {
				--background: #10131b;
				--surface: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--hover: #10131b;
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
			}

			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative;
			}

			.hidden {
				display: none !important;
			}

			h1, h2 {
				margin: 0.5rem 0;
			}

			label {
				display: block;
				font-weight: 700;
				margin-bottom: 0.5rem;
			}

			input, select, textarea, button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: 0.5rem;
				width: 100%;
			}

			textarea {
				min-height: 80px;
				resize: vertical;
			}

			button {
				cursor: pointer;
				transition: background 0.2s;
			}

			.button-primary {
				background: var(--primary);
				border: none;
				color: #fff;
			}

			.button-primary:hover {
				background: var(--primary-hover);
			}

			.button-secondary:hover {
				background: var(--hover);
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px;
			}

			.selectors select {
				font-size: 0.9rem;
				padding: 5px;
				width: auto;
			}

			.checkbox-container {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: 0.75rem 0;
			}

			.checkbox-container input {
				width: auto;
			}

			.checkbox-container label {
				margin: 0;
			}

			#battleContainer, #tieButtonContainer, #restartButtonContainer {
				display: flex;
				gap: 1rem;
				margin-top: 1rem;
			}

			#battleContainer button, #tieButtonContainer button, #restartButtonContainer button {
				flex: 1;
			}

			#battleContainer button, #tieButtonContainer button {
				font-size: 1.2rem;
				min-height: 100px;
			}

			#progressDisplay {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center;
			}

			#keyboardShortcutTip {
				background: var(--background);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: 0.85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: 0.9;
				padding: 8px;
				text-align: center;
			}

			#keyboardShortcutTip kbd {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0,0,0,0.2);
				display: inline-block;
				font-family: monospace;
				font-size: 0.9em;
				margin: 0 3px;
				padding: 2px 5px;
			}

			#keyboardShortcutToggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: 0.85rem;
				margin: 10px auto 0;
				text-decoration: underline;
				width: auto;
			}

			#resultsContainer table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%;
			}

			#resultsContainer th, #resultsContainer td {
				border: 1px solid var(--border);
				padding: 0.5rem;
				text-align: left;
			}

			#resultsContainer th {
				background: var(--primary);
				color: #fff;
			}

			#undoButton {
				width: auto;
			}

			#undoButton:disabled {
				background: var(--hover);
				cursor: not-allowed;
			}

			.selected {
				background: var(--primary) !important;
				color: #fff !important;
			}

			@media (max-width: 768px) {
				body {
					padding: 0.75rem;
				}

				.container {
					padding: 1.5rem;
				}

				.selectors {
					position: static;
					justify-content: flex-end;
					margin-bottom: 0.5rem;
					gap: 4px;
				}

				.selectors select {
					font-size: 0.8rem;
					padding: 4px;
				}

				#battleContainer, #tieButtonContainer, #restartButtonContainer {
					flex-direction: column;
				}

				#battleContainer button, #tieButtonContainer button {
					width: 100%;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="inputSection">
				<h1 id="mainTitle"></h1>
				<div class="selectors">
					<select id="languageSelection">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="themeSelection">
						<option value="auto"></option>
						<option value="light"></option>
						<option value="dark"></option>
					</select>
				</div>
				<div class="form-group">
					<label for="itemInputArea" id="itemInputLabel"></label>
					<textarea id="itemInputArea" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox-container">
					<input type="checkbox" id="allowTiesCheckbox">
					<label for="allowTiesCheckbox" id="allowTiesLabel"></label>
				</div>
				<div class="checkbox-container">
					<input type="checkbox" id="quickRankCheckbox">
					<label for="quickRankCheckbox" id="quickRankLabel"></label>
				</div>
				<button id="startRankingButton" class="button-primary"></button>
			</div>
			<div id="battleSection" class="hidden">
				<button id="undoButton" class="button-secondary" disabled></button>
				<div id="battleContainer">
					<button id="leftItemButton" class="button-secondary"></button>
					<button id="rightItemButton" class="button-secondary"></button>
				</div>
				<div id="tieButtonContainer" class="hidden">
					<button id="tieButton" class="button-secondary"></button>
				</div>
				<div id="progressDisplay"></div>
				<button id="keyboardShortcutToggle"></button>
				<div id="keyboardShortcutTip" class="hidden"></div>
			</div>
			<div id="resultsContainer" class="hidden"></div>
			<div id="restartButtonContainer" class="hidden">
				<button id="restartBattleButton" class="button-primary"></button>
				<button id="restartNewButton" class="button-primary"></button>
			</div>
		</div>
		<script>
			const languageStrings = {
				en: {
					title: 'PreferenceRank',
					automaticTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
					itemInputLabel: 'Enter items, one per line:',
					allowTiesLabel: 'Allow Ties',
					quickRankLabel: 'Use Quick Rank (fewer comparisons)',
					alertMessage: 'Please enter at least two items.',
					duplicateAlertMessage: '{count} duplicate item(s) were found and have been removed.',
					startRankingButton: 'Start Ranking',
					tieButton: "It's a Tie",
					undoButton: 'Undo',
					progressLabel: 'Progress',
					keyboardShortcutToggle: 'Show keyboard shortcuts',
					keyboardShortcutHide: 'Hide keyboard shortcuts',
					keyboardShortcutTipWithTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> / <kbd>↓</kbd> It\'s a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					keyboardShortcutTipNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					resultsTitle: 'Results',
					rankColumn: 'Rank',
					itemColumn: 'Item',
					scoreColumn: 'Score',
					restartBattleButton: 'Restart Battle',
					restartNewButton: 'Start with New Items'
				},
				id: {
					title: 'PreferenceRank',
					automaticTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
					itemInputLabel: 'Masukkan pilihan, satu per baris:',
					allowTiesLabel: 'Izinkan Seri',
					quickRankLabel: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
					alertMessage: 'Harap masukkan setidaknya dua pilihan.',
					duplicateAlertMessage: '{count} item duplikat ditemukan dan telah dihapus.',
					startRankingButton: 'Mulai Peringkat',
					tieButton: 'Seri',
					undoButton: 'Urungkan',
					progressLabel: 'Kemajuan',
					keyboardShortcutToggle: 'Tampilkan pintasan papan ketik',
					keyboardShortcutHide: 'Sembunyikan pintasan papan ketik',
					keyboardShortcutTipWithTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> / <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					keyboardShortcutTipNoTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					resultsTitle: 'Hasil',
					rankColumn: 'Peringkat',
					itemColumn: 'Nama',
					scoreColumn: 'Skor',
					restartBattleButton: 'Mulai Ulang Pertarungan',
					restartNewButton: 'Mulai dengan Pilihan Baru'
				}
			};

			const escapeHtml = text=>{
				const element = document.createElement('p');
				element.textContent = text;
				return element.innerHTML;
			}
			;

			class PairProvider {
				constructor(itemCount) {
					this.itemCount = itemCount;
					this.comparedPairKeys = new Set();
				}
				createPairKey([firstIndex,secondIndex]) {
					return `${Math.min(firstIndex, secondIndex)}-${Math.max(firstIndex, secondIndex)}`;
				}
				markCompared(pair) {
					this.comparedPairKeys.add(this.createPairKey(pair));
				}
				unmarkCompared(pair) {
					this.comparedPairKeys.delete(this.createPairKey(pair));
				}
				hasBeenCompared(pair) {
					return this.comparedPairKeys.has(this.createPairKey(pair));
				}
			}

			class FullPairProvider extends PairProvider {
				constructor(itemCount) {
					super(itemCount);
					this.pairs = [];
					for (let i = 0; i < itemCount - 1; i++) {
						for (let j = i + 1; j < itemCount; j++) {
							this.pairs.push([i, j]);
						}
					}
					for (let i = this.pairs.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						const temporary = this.pairs[i];
						this.pairs[i] = this.pairs[j];
						this.pairs[j] = temporary;
					}
				}
				getNextPair(state) {
					return this.pairs[state.progress];
				}
				getTotalPairs() {
					return this.pairs.length;
				}
			}

			class QuickPairProvider extends PairProvider {
				getNextPair(state) {
					const sortedIndices = Array.from({
						length: this.itemCount
					}, (_,index)=>index).sort((a,b)=>state.scores[b] - state.scores[a]);

					for (let i = 0; i < this.itemCount - 1; i++) {
						const pair = [sortedIndices[i], sortedIndices[i + 1]];
						if (!this.hasBeenCompared(pair))
							return pair;
					}
					return null;
				}
			}

			class PreferenceRank {
				constructor() {
					this.elements = {};
					document.querySelectorAll('[id]').forEach(element=>{
						this.elements[element.id] = element;
					}
					);

					const detectedLanguageCode = navigator.language?.startsWith('id') ? 'id' : 'en';

					this.state = {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: false,
						progress: 0,
						totalPairs: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						isChoosing: false,
						language: detectedLanguageCode,
						theme: 'auto',
						pairProvider: null,
						pairSwaps: new Map()
					};

					this.initialize();
				}

				translate(key) {
					return languageStrings[this.state.language][key];
				}

				formatString(key, replacements) {
					let text = this.translate(key);
					if (replacements) {
						for (const [placeholder,value] of Object.entries(replacements)) {
							text = text.replace(`{${placeholder}}`, value);
						}
					}
					return text;
				}

				initialize() {
					this.bindEvents();
					this.setTheme('auto');
					this.updateLanguage(this.state.language);
				}

				bindEvents() {
					const elements = this.elements;

					elements.startRankingButton.addEventListener('click', ()=>this.startRanking());
					elements.leftItemButton.addEventListener('click', ()=>this.handleChoice('left'));
					elements.rightItemButton.addEventListener('click', ()=>this.handleChoice('right'));
					elements.tieButton.addEventListener('click', ()=>this.handleChoice('tie'));
					elements.restartBattleButton.addEventListener('click', ()=>this.restartBattle());
					elements.restartNewButton.addEventListener('click', ()=>this.restartWithNewItems());
					elements.undoButton.addEventListener('click', ()=>this.undoLastChoice());
					elements.keyboardShortcutToggle.addEventListener('click', ()=>this.toggleKeyboardTip());

					elements.languageSelection.addEventListener('change', event=>{
						this.updateLanguage(event.target.value);
					}
					);

					elements.themeSelection.addEventListener('change', event=>{
						this.setTheme(event.target.value);
					}
					);

					elements.allowTiesCheckbox.addEventListener('change', event=>{
						this.handleAllowTiesChange(event.target.checked);
					}
					);

					document.addEventListener('keydown', event=>this.handleKeyboard(event));
				}

				setTheme(theme) {
					const documentRoot = document.documentElement;
					documentRoot.classList.remove('light', 'dark');
					if (theme !== 'auto') {
						documentRoot.classList.add(theme);
					}
					this.elements.themeSelection.value = theme;
					this.state.theme = theme;
				}

				updateLanguage(language) {
					this.state.language = language;
					this.elements.languageSelection.value = language;
					document.documentElement.lang = language;

					const elements = this.elements;
					const strings = languageStrings[language];

					elements.mainTitle.textContent = strings.title;

					const themeOptions = elements.themeSelection.options;
					themeOptions[0].textContent = strings.automaticTheme;
					themeOptions[1].textContent = strings.lightTheme;
					themeOptions[2].textContent = strings.darkTheme;

					elements.itemInputLabel.textContent = strings.itemInputLabel;
					elements.allowTiesLabel.textContent = strings.allowTiesLabel;
					elements.quickRankLabel.textContent = strings.quickRankLabel;
					elements.startRankingButton.textContent = strings.startRankingButton;
					elements.tieButton.textContent = strings.tieButton;
					elements.undoButton.textContent = strings.undoButton;
					elements.restartBattleButton.textContent = strings.restartBattleButton;
					elements.restartNewButton.textContent = strings.restartNewButton;

					this.updateKeyboardTip();
					this.updateProgressDisplay();

					if (!elements.resultsContainer.classList.contains('hidden')) {
						this.displayResults();
					}
				}

				updateKeyboardTip() {
					const keyboardShortcutTipElement = this.elements.keyboardShortcutTip;
					const keyboardShortcutToggleElement = this.elements.keyboardShortcutToggle;
					const isHidden = keyboardShortcutTipElement.classList.contains('hidden');

					keyboardShortcutToggleElement.textContent = isHidden ? this.translate('keyboardShortcutToggle') : this.translate('keyboardShortcutHide');

					keyboardShortcutTipElement.innerHTML = this.translate(this.state.allowTies ? 'keyboardShortcutTipWithTies' : 'keyboardShortcutTipNoTies');
				}

				handleAllowTiesChange(checked) {
					this.state.allowTies = checked;
					if (!this.elements.battleSection.classList.contains('hidden')) {
						this.elements.tieButtonContainer.classList.toggle('hidden', !checked);
					}
					this.updateKeyboardTip();
				}

				resetBattleState() {
					const itemCount = this.state.items.length;
					const isQuickRank = this.elements.quickRankCheckbox.checked;

					this.state.scores = Array(itemCount).fill(1000);
					this.state.progress = 0;
					this.state.history = [];
					this.state.pairSwaps = new Map();
					this.elements.undoButton.disabled = true;

					this.state.pairProvider = isQuickRank ? new QuickPairProvider(itemCount) : new FullPairProvider(itemCount);

					this.state.totalPairs = isQuickRank ? 0 : this.state.pairProvider.getTotalPairs();
				}

				startRanking() {
					const rawItems = this.elements.itemInputArea.value.split('\n').map(line=>line.trim()).filter(Boolean);

					const uniqueItems = [...new Set(rawItems)];
					const duplicateCount = rawItems.length - uniqueItems.length;

					if (duplicateCount > 0) {
						alert(this.formatString('duplicateAlertMessage', {
							count: duplicateCount
						}));
					}
					if (uniqueItems.length < 2) {
						alert(this.translate('alertMessage'));
						return;
					}

					this.state.items = uniqueItems;
					this.state.allowTies = this.elements.allowTiesCheckbox.checked;

					this.resetBattleState();
					this.elements.tieButtonContainer.classList.toggle('hidden', !this.state.allowTies);
					this.toggleKeyboardTip(true);
					this.updateKeyboardTip();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				calculateScores(winner) {
					const {currentPair, isSwapped, scores} = this.state;
					const isFirstWinner = (winner === 'left' && !isSwapped) || (winner === 'right' && isSwapped);
					const resultScore = winner === 'tie' ? 0.5 : isFirstWinner ? 1 : 0;

					const [firstIndex,secondIndex] = currentPair;
					const firstScore = scores[firstIndex];
					const secondScore = scores[secondIndex];

					const expectedFirst = 1 / (1 + 10 ** ((secondScore - firstScore) / 400));
					const adjustment = 32;

					scores[firstIndex] += adjustment * (resultScore - expectedFirst);
					scores[secondIndex] += adjustment * (expectedFirst - resultScore);
				}

				handleChoice(winner) {
					if (this.state.isChoosing)
						return;
					this.state.isChoosing = true;

					this.state.history.push({
						pair: this.state.currentPair,
						scores: [...this.state.scores],
						progress: this.state.progress,
						isSwapped: this.state.isSwapped
					});

					this.state.pairProvider.markCompared(this.state.currentPair);
					this.calculateScores(winner);
					this.state.progress++;
					this.elements.undoButton.disabled = false;
					this.updateProgressDisplay();
					this.clearSelections();

					const targetButton = winner === 'tie' ? this.elements.tieButton : this.elements[`${winner}ItemButton`];

					targetButton.classList.add('selected');

					setTimeout(()=>{
						this.state.isChoosing = false;
						this.showNextBattle();
					}
					, 300);
				}

				displayCurrentBattle() {
					this.clearSelections();
					let[firstIndex,secondIndex] = this.state.currentPair;
					if (this.state.isSwapped) {
						const temporary = firstIndex;
						firstIndex = secondIndex;
						secondIndex = temporary;
					}

					this.elements.leftItemButton.textContent = this.state.items[firstIndex];
					this.elements.rightItemButton.textContent = this.state.items[secondIndex];
					this.updateProgressDisplay();
				}

				showNextBattle() {
					this.clearSelections();

					const nextPair = this.state.pairProvider.getNextPair(this.state);
					const isQuickRank = this.elements.quickRankCheckbox.checked;

					if (!nextPair || (!isQuickRank && this.state.progress >= this.state.totalPairs)) {
						this.displayResults();
						return;
					}

					this.state.currentPair = nextPair;
					const pairKey = this.state.pairProvider.createPairKey(nextPair);

					if (!this.state.pairSwaps.has(pairKey)) {
						this.state.pairSwaps.set(pairKey, Math.random() < 0.5);
					}
					this.state.isSwapped = this.state.pairSwaps.get(pairKey);

					this.displayCurrentBattle();
				}

				updateProgressDisplay() {
					const label = this.translate('progressLabel');
					const isQuickRank = this.elements.quickRankCheckbox.checked;
					const progress = this.state.progress;
					const totalPairs = this.state.totalPairs;

					this.elements.progressDisplay.textContent = isQuickRank ? `${label}: ${progress}` : `${label}: ${progress}/${totalPairs || 0}`;
				}

				clearSelections() {
					['leftItemButton', 'rightItemButton', 'tieButton'].forEach(id=>{
						this.elements[id].classList.remove('selected');
					}
					);
				}

				displayResults() {
					const results = this.state.items.map((item,index)=>({
						item,
						score: this.state.scores[index]
					})).sort((a,b)=>b.score - a.score);

					const headerRowHtml = `
					<th style="width:20%">${this.translate('rankColumn')}</th>
					<th style="width:60%">${this.translate('itemColumn')}</th>
					<th style="width:20%">${this.translate('scoreColumn')}</th>
				`;

					const bodyRowsHtml = results.map((result,index)=>`<tr><td>${index + 1}</td><td>${escapeHtml(result.item)}</td><td>${Math.round(result.score)}</td></tr>`).join('');

					this.elements.resultsContainer.innerHTML = `
					<h2>${this.translate('resultsTitle')}</h2>
					<table>
						<thead><tr>${headerRowHtml}</tr></thead>
						<tbody>${bodyRowsHtml}</tbody>
					</table>
				`;

					this.showSection('resultsContainer');
				}

				showSection(sectionId) {
					['inputSection', 'battleSection', 'resultsContainer'].forEach(id=>{
						this.elements[id].classList.toggle('hidden', id !== sectionId);
					}
					);
					this.elements.restartButtonContainer.classList.toggle('hidden', sectionId !== 'resultsContainer');
					this.state.keyboardEnabled = sectionId === 'battleSection';
				}

				undoLastChoice() {
					if (this.state.isChoosing || !this.state.history.length)
						return;

					const lastState = this.state.history.pop();
					this.state.scores = lastState.scores;
					this.state.progress = lastState.progress;
					this.state.currentPair = lastState.pair;
					this.state.isSwapped = lastState.isSwapped;
					this.state.pairProvider.unmarkCompared(lastState.pair);

					this.displayCurrentBattle();
					this.elements.undoButton.disabled = !this.state.history.length;
				}

				restartBattle() {
					this.resetBattleState();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				restartWithNewItems() {
					const language = this.state.language;
					const theme = this.state.theme;

					this.state = {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: false,
						progress: 0,
						totalPairs: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						isChoosing: false,
						language,
						theme,
						pairProvider: null,
						pairSwaps: new Map()
					};

					this.elements.itemInputArea.value = '';
					this.elements.allowTiesCheckbox.checked = false;
					this.elements.quickRankCheckbox.checked = false;

					this.showSection('inputSection');
					this.updateLanguage(language);
					this.setTheme(theme);
					this.toggleKeyboardTip(true);
					this.updateProgressDisplay();
				}

				toggleKeyboardTip(forceHidden) {
					const keyboardShortcutTipElement = this.elements.keyboardShortcutTip;
					const shouldHide = typeof forceHidden === 'boolean' ? forceHidden : !keyboardShortcutTipElement.classList.contains('hidden');

					keyboardShortcutTipElement.classList.toggle('hidden', shouldHide);
					this.updateKeyboardTip();
				}

				handleKeyboard(event) {
					const activeTagName = document.activeElement.tagName;
					if (!this.state.keyboardEnabled || ['SELECT', 'INPUT', 'TEXTAREA'].includes(activeTagName)) {
						return;
					}

					const keyToElementIdMap = {
						ArrowLeft: 'leftItemButton',
						ArrowRight: 'rightItemButton',
						ArrowUp: 'tieButton',
						ArrowDown: 'tieButton',
						z: 'undoButton'
					};

					const targetElementId = keyToElementIdMap[event.key];
					if (!targetElementId)
						return;

					const isUndo = event.key === 'z';
					const isArrowUpOrDown = event.key === 'ArrowUp' || event.key === 'ArrowDown';

					if (isUndo && !(event.ctrlKey || event.metaKey))
						return;
					if (isArrowUpOrDown && !this.state.allowTies)
						return;

					event.preventDefault();
					this.elements[targetElementId].click();
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
