<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--hover: #005bc0;
				--background: #f9f9ff;
				--surface: #fff;
				--text: #414754;
				--border: #c1c6d7;
				--dim: #d7d9e5
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--background:#10131b;
					--surface: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--dim: #10131b
				}
			}

			:root.dark {
				--background: #10131b;
				--surface: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--dim: #10131b
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem
			}

			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative
			}

			.hidden {
				display: none!important
			}

			h1,h2,label {
				margin-bottom: .5rem;
				display: block
			}

			h1,h2 {
				margin-top: .5rem
			}

			label {
				font-weight: 700
			}

			input,select,textarea,button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%
			}

			textarea {
				min-height: 80px;
				resize: vertical
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			.primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.primary:hover {
				background: var(--hover)
			}

			.secondary:hover {
				background: var(--dim)
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px
			}

			.selectors select {
				font-size: .9rem;
				padding: 5px;
				width: auto
			}

			.checkbox-row {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: .75rem 0
			}

			.checkbox-row input {
				width: auto
			}

			.checkbox-row label {
				margin: 0
			}

			#battle,#tieWrap,#restartWrap {
				display: flex;
				gap: 1rem;
				margin-top: 1rem
			}

			#battle button,#tieWrap button,#restartWrap button {
				flex: 1
			}

			#battle button,#tieWrap button {
				font-size: 1.2rem;
				min-height: 100px
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center
			}

			#tips {
				background: var(--background);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: .9;
				padding: 8px;
				text-align: center
			}

			kbd {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px #0003;
				display: inline-block;
				font-family: monospace;
				font-size: .9em;
				margin: 0 3px;
				padding: 2px 5px
			}

			#cancel,#toggle {
				background: none;
				border: 1px solid var(--border);
				color: var(--text);
				cursor: pointer;
				display: block;
				font-size: .9rem;
				margin: 1rem auto;
				padding: 5px 15px;
				width: auto
			}

			#cancel:hover {
				background: var(--dim)
			}

			#toggle {
				border: none;
				color: var(--primary);
				font-size: .85rem;
				margin-top: 10px;
				text-decoration: underline
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%
			}

			#results th,#results td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left
			}

			#results th {
				background: var(--primary);
				color: #fff
			}

			.results-header {
				display: flex;
				justify-content: center;
				align-items: center;
				position: relative;
				min-height: 40px;
				margin-bottom: 1rem
			}

			.results-header h2 {
				margin: 0
			}

			.results-header #undo {
				position: absolute;
				left: 0;
				top: 50%;
				transform: translateY(-50%)
			}

			#undo {
				width: auto
			}

			#undo:disabled {
				background: var(--dim);
				cursor: not-allowed
			}

			.selected {
				background: var(--primary)!important;
				color: #fff!important
			}

			@media(max-width: 768px) {
				body {
					padding:.75rem
				}

				.container {
					padding: 1.5rem
				}

				.selectors {
					position: static;
					justify-content: flex-end;
					margin-bottom: .5rem;
					gap: 4px
				}

				.selectors select {
					font-size: .8rem;
					padding: 4px
				}

				#battle,#tieWrap,#restartWrap {
					flex-direction: column
				}

				#battle button,#tieWrap button {
					width: 100%
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="inputSection">
				<div class="selectors">
					<select id="language">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="theme">
						<option value="auto"></option>
						<option value="light"></option>
						<option value="dark"></option>
					</select>
				</div>
				<h1 id="title"></h1>
				<div class="group">
					<label for="items" id="labelItems"></label>
					<textarea id="items" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox-row">
					<input type="checkbox" id="allowTies">
					<label for="allowTies" id="labelTies"></label>
				</div>
				<div class="checkbox-row">
					<input type="checkbox" id="quickRank">
					<label for="quickRank" id="labelQuick"></label>
				</div>
				<button id="start" class="primary"></button>
			</div>
			<button id="undo" class="secondary hidden" disabled></button>
			<div id="battleSection" class="hidden">
				<div id="battle">
					<button id="left" class="secondary"></button>
					<button id="right" class="secondary"></button>
				</div>
				<div id="tieWrap" class="hidden">
					<button id="tie" class="secondary"></button>
				</div>
				<div id="progress"></div>
				<button id="cancel"></button>
				<button id="toggle"></button>
				<div id="tips" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartWrap" class="hidden">
				<button id="restartBattle" class="primary"></button>
				<button id="restartNew" class="primary"></button>
			</div>
		</div>
		<script>
			const strings = {
				en: {
					title: 'PreferenceRank',
					auto: 'Auto Theme',
					light: 'Light',
					dark: 'Dark',
					labelItems: 'Enter items, one per line:',
					labelTies: 'Allow Ties',
					labelQuick: 'Use Quick Rank (fewer comparisons)',
					alert: 'Please enter at least two items.',
					duplicate: '{count} duplicate item(s) removed.',
					start: 'Start Ranking',
					cancel: 'Cancel',
					tie: "It's a Tie",
					undo: 'Undo',
					progress: 'Progress',
					toggleShow: 'Show keyboard shortcuts',
					toggleHide: 'Hide keyboard shortcuts',
					tipTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>↑</kbd>/<kbd>↓</kbd> Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
					tipNoTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
					resultsTitle: 'Results',
					rank: 'Rank',
					item: 'Item',
					score: 'Score',
					restartBattle: 'Restart Battle',
					restartNew: 'Start with New Items'
				},
				id: {
					title: 'PreferenceRank',
					auto: 'Tema Otomatis',
					light: 'Terang',
					dark: 'Gelap',
					labelItems: 'Masukkan pilihan, satu per baris:',
					labelTies: 'Izinkan Seri',
					labelQuick: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
					alert: 'Harap masukkan setidaknya dua pilihan.',
					duplicate: '{count} item duplikat dihapus.',
					start: 'Mulai Peringkat',
					cancel: 'Batal',
					tie: 'Seri',
					undo: 'Urungkan',
					progress: 'Kemajuan',
					toggleShow: 'Tampilkan pintasan papan ketik',
					toggleHide: 'Sembunyikan pintasan papan ketik',
					tipTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>↑</kbd>/<kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
					tipNoTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
					resultsTitle: 'Hasil',
					rank: 'Peringkat',
					item: 'Nama',
					score: 'Skor',
					restartBattle: 'Mulai Ulang Pertarungan',
					restartNew: 'Mulai dengan Pilihan Baru'
				}
			};

			const escape = text=>Object.assign(document.createElement('span'), {
				textContent: text
			}).innerHTML;
			const dom = Object.fromEntries([...document.querySelectorAll('[id]')].map(element=>[element.id, element]));

			class PairProvider {
				constructor(count) {
					this.count = count;
					this.compared = new Set();
				}
				key([a,b]) {
					return a < b ? `${a}-${b}` : `${b}-${a}`;
				}
				mark(pair) {
					this.compared.add(this.key(pair));
				}
				unmark(pair) {
					this.compared.delete(this.key(pair));
				}
				getResults(items, scores) {
					return items.map((text,index)=>({
						text,
						score: scores[index]
					})).sort((a,b)=>b.score - a.score);
				}
				getProgress(step) {
					return step;
				}
			}

			class FullPairProvider extends PairProvider {
				constructor(count) {
					super(count);
					this.pairs = [];
					for (let i = 0; i < count - 1; i++)
						for (let j = i + 1; j < count; j++)
							this.pairs.push([i, j]);
					for (let i = this.pairs.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[this.pairs[i],this.pairs[j]] = [this.pairs[j], this.pairs[i]];
					}
				}
				next(state) {
					return this.pairs[state.step];
				}
				getProgress(step) {
					return `${step}/${this.pairs.length}`;
				}
			}

			class QuickPairProvider extends PairProvider {
				constructor(count) {
					super(count);
					this.stack = [{
						stage: 'init',
						items: [...Array(count).keys()]
					}];
					this.history = [];
					this.pending = null;
					this.previousScores = null;
					this.final = null;
					this.refinePass = 0;
					this.refineIndex = 0;
					this.refineSwapped = false;

					this.jacobsthal = [0, 1];
					while (this.jacobsthal[this.jacobsthal.length - 1] < count) {
						const len = this.jacobsthal.length;
						this.jacobsthal.push(this.jacobsthal[len - 1] + 2 * this.jacobsthal[len - 2]);
					}
				}

				snapshot() {
					return JSON.stringify({
						stack: this.stack,
						pending: this.pending,
						previousScores: this.previousScores,
						compared: [...this.compared],
						final: this.final,
						refinePass: this.refinePass,
						refineIndex: this.refineIndex,
						refineSwapped: this.refineSwapped
					});
				}

				restore(json) {
					Object.assign(this, JSON.parse(json));
					this.compared = new Set(this.compared);
				}

				unmark(pair) {
					this.pending && this.history.length && this.history.pop();
					this.history.length && this.restore(this.history[this.history.length - 1]);
					super.unmark(pair);
				}

				next(state) {
					this.previousScores ??= [...state.scores];
					this.pending && this.handlePending(state);

					const handlers = {
						init: frame => this.handleInit(frame),
						comparing: frame => this.handleComparing(frame),
						recursion: frame => this.handleRecursion(frame),
						grouping: frame => this.handleGrouping(frame),
						inserting: frame => this.handleInserting(frame)
					};

					while (this.stack.length) {
						const frame = this.stack[this.stack.length - 1];
						const result = handlers[frame.stage](frame);
						if (result) return result;
					}

					return this.final ? this.handleRefinement() : null;
				}

				handlePending(state) {
					const [a,b] = this.pending;
					const change = state.scores[a] - this.previousScores[a];
					const expected = 1 / (1 + 10 ** ((this.previousScores[b] - this.previousScores[a]) / 400));
					const result = (change / 32) + expected;
					const winner = Math.abs(result - 0.5) < 0.01 ? a : result > 0.75 ? a : b;

					const frame = this.stack[this.stack.length - 1];
					frame && (frame.lastWinner = winner);

					this.final && (winner === b && this.final.indexOf(a) !== -1 && this.final[this.final.indexOf(a) + 1] === b &&
						([this.final[this.final.indexOf(a)],this.final[this.final.indexOf(a) + 1]] = [this.final[this.final.indexOf(a) + 1], this.final[this.final.indexOf(a)]],
						this.refineSwapped = true),
					this.refineIndex++);

					this.pending = null;
					this.previousScores = [...state.scores];
				}

				handleInit(frame) {
					if (frame.items.length < 2) {
						this.returnResult(frame.items);
						return;
					}
					frame.pairs = [];
					frame.straggler = null;
					for (let i = 0; i < Math.floor(frame.items.length / 2); i++)
						frame.pairs.push([frame.items[2 * i], frame.items[2 * i + 1]]);
					frame.items.length % 2 && (frame.straggler = frame.items[frame.items.length - 1]);

					frame.winners = [];
					frame.losers = [];
					frame.pairIdx = 0;
					frame.stage = 'comparing';
				}

				handleComparing(frame) {
					if (frame.pairIdx >= frame.pairs.length) {
						frame.stage = 'recursion';
						this.stack.push({
							stage: 'init',
							items: [...frame.winners]
						});
						return;
					}

					const pair = frame.pairs[frame.pairIdx];
					if (frame.lastWinner !== undefined) {
						const winner = frame.lastWinner;
						const loser = winner === pair[0] ? pair[1] : pair[0];
						frame.winners.push(winner);
						frame.losers.push(loser);
						delete frame.lastWinner;
						frame.pairIdx++;
						return;
					}
					this.pending = pair;
					this.history.push(this.snapshot());
					return this.pending;
				}

				handleRecursion(frame) {
					if (!frame.subResult) return null; // Wait for recursion

					frame.mainChain = frame.subResult;
					delete frame.subResult;
					frame.pairMap = {};
					for (let i = 0; i < frame.winners.length; i++)
						frame.pairMap[frame.winners[i]] = frame.losers[i];

					const firstWinner = frame.mainChain[0];
					const b1 = frame.pairMap[firstWinner];
					frame.mainChain.unshift(b1);

					const sortedWinners = frame.mainChain.slice(1);
					frame.insertions = [];
					for (let i = 0; i < sortedWinners.length; i++) {
						const winner = sortedWinners[i];
						const loser = frame.pairMap[winner];
						i > 0 && frame.insertions.push({
							item: loser,
							boundItem: winner
						});
					}
					frame.straggler !== null && frame.insertions.push({
						item: frame.straggler,
						boundItem: null
					});

					frame.jacobIdx = 2;
					frame.currentGroup = [];
					frame.stage = 'grouping';
				}

				handleGrouping(frame) {
					if (frame.currentGroup.length === 0) {
						const prevJ = this.jacobsthal[frame.jacobIdx - 1];
						const currJ = this.jacobsthal[frame.jacobIdx];
						const minIdx = prevJ - 1;
						const maxIdx = currJ - 2;

						if (minIdx >= frame.insertions.length) {
							this.returnResult(frame.mainChain);
							return;
						}
						for (let i = Math.min(maxIdx, frame.insertions.length - 1); i >= minIdx; i--)
							frame.currentGroup.push(frame.insertions[i]);
						frame.jacobIdx++;
					}

					if (frame.currentGroup.length > 0) {
						frame.currentItem = frame.currentGroup.shift();
						frame.stage = 'inserting';
						const boundItem = frame.currentItem.boundItem;
						let max = frame.mainChain.length;
						boundItem !== null && (max = frame.mainChain.indexOf(boundItem));
						frame.bs = {
							min: 0,
							max: max,
							target: frame.currentItem.item
						};
					}
				}

				handleInserting(frame) {
					const {min, max, target} = frame.bs;
					if (min >= max) {
						frame.mainChain.splice(min, 0, target);
						frame.stage = 'grouping';
						return;
					}
					const mid = Math.floor((min + max) / 2);
					frame.bs.mid = mid;
					const compareItem = frame.mainChain[mid];

					if (frame.lastWinner !== undefined) {
						const winner = frame.lastWinner;
						delete frame.lastWinner;
						winner === target ? (frame.bs.min = mid + 1) : (frame.bs.max = mid);
						return;
					}
					this.pending = [target, compareItem];
					this.history.push(this.snapshot());
					return this.pending;
				}

				handleRefinement() {
					while (true) {
						if (this.refinePass >= 2) return null;
						if (this.refineIndex >= this.final.length - 1) {
							if (!this.refineSwapped) return null;
							this.refinePass++;
							this.refineIndex = 0;
							this.refineSwapped = false;
							continue;
						}
						const [a,b] = [this.final[this.refineIndex], this.final[this.refineIndex + 1]];
						if (this.compared.has(this.key([a, b]))) {
							this.refineIndex++;
							continue;
						}
						this.pending = [a, b];
						this.history.push(this.snapshot());
						return this.pending;
					}
				}

				returnResult(result) {
					this.stack.pop();
					if (this.stack.length) {
						const frame = this.stack[this.stack.length - 1];
						frame.subResult = result;
					} else {
						this.final = result.reverse();
					}
				}

				getResults(items, scores) {
					return this.final ? this.final.map(index=>({
						text: items[index],
						score: scores[index]
					})) : super.getResults(items, scores);
				}
			}

			class PreferenceRank {
				constructor() {
					Object.assign(this, {
						items: [],
						scores: [],
						pair: null,
						swapped: false,
						step: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						busy: false,
						swaps: new Map(),
						language: navigator.language.startsWith('id') ? 'id' : 'en',
						provider: null
					});
					this.bind();
					this.setTheme('auto');
					this.updateText();
				}

				text(key) {
					return strings[this.language]?.[key] ?? key;
				}

				bind() {
					dom.start.onclick = ()=>this.start();
					dom.cancel.onclick = ()=>this.show('inputSection');
					dom.left.onclick = ()=>this.choose('left');
					dom.right.onclick = ()=>this.choose('right');
					dom.tie.onclick = ()=>this.choose('tie');
					dom.restartBattle.onclick = ()=>this.start();
					dom.restartNew.onclick = ()=>this.reset();
					dom.undo.onclick = ()=>this.undo();
					dom.toggle.onclick = ()=>this.toggleHelp();
					dom.language.onchange = event=>{
						this.language = event.target.value;
						this.updateText();
					}
					;
					dom.theme.onchange = event=>this.setTheme(event.target.value);
					dom.allowTies.onchange = event=>this.setTies(event.target.checked);
					document.onkeydown = event=>this.handleKey(event);
				}

				setTheme(theme) {
					document.documentElement.className = theme === 'auto' ? '' : theme;
					dom.theme.value = theme;
				}

				updateText() {
					dom.language.value = this.language;
					['title', 'labelItems', 'labelTies', 'labelQuick', 'start', 'cancel', 'tie', 'undo', 'restartBattle', 'restartNew'].forEach(key=>dom[key].textContent = this.text(key));
					dom.toggle.textContent = this.text(dom.tips.classList.contains('hidden') ? 'toggleShow' : 'toggleHide');
					[['auto', 0], ['light', 1], ['dark', 2]].forEach(([key,index])=>dom.theme.options[index].textContent = this.text(key));
					this.updateHelp();
					this.updateProgress();
					!dom.results.classList.contains('hidden') && this.renderResults();
				}

				setTies(enabled) {
					this.allowTies = enabled;
					!dom.battleSection.classList.contains('hidden') && dom.tieWrap.classList.toggle('hidden', !enabled);
					this.updateHelp();
				}
				updateHelp() {
					dom.toggle.textContent = this.text(dom.tips.classList.contains('hidden') ? 'toggleShow' : 'toggleHide');
					dom.tips.innerHTML = this.text(this.allowTies ? 'tipTie' : 'tipNoTie');
				}
				toggleHelp() {
					dom.tips.classList.toggle('hidden');
					this.updateHelp();
				}

				start() {
					const raw = dom.items.value.split('\n').map(line=>line.trim()).filter(Boolean);
					const unique = [...new Set(raw)];
					raw.length > unique.length && alert(this.text('duplicate').replace('{count}', raw.length - unique.length));
					if (unique.length < 2)
						return alert(this.text('alert'));
					Object.assign(this, {
						items: unique,
						allowTies: dom.allowTies.checked,
						scores: Array(unique.length).fill(1000),
						step: 0,
						history: [],
						swaps: new Map(),
						busy: false
					});
					dom.undo.disabled = true;
					this.provider = dom.quickRank.checked ? new QuickPairProvider(unique.length) : new FullPairProvider(unique.length);
					dom.tieWrap.classList.toggle('hidden', !this.allowTies);
					this.updateHelp();
					this.show('battleSection');
					this.next();
				}

				choose(winner) {
					if (this.busy || dom.battleSection.classList.contains('hidden'))
						return;
					this.busy = true;
					this.history.push({
						pair: this.pair,
						scores: [...this.scores],
						step: this.step,
						swapped: this.swapped
					});
					this.provider.mark(this.pair);
					const [a,b] = this.pair;
					const isLeftWinner = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
					const result = winner === 'tie' ? 0.5 : isLeftWinner ? 1 : 0;
					const expected = 1 / (1 + 10 ** ((this.scores[b] - this.scores[a]) / 400));
					this.scores[a] += 32 * (result - expected);
					this.scores[b] += 32 * (expected - result);
					this.step++;
					dom.undo.disabled = false;
					this.updateProgress();
					this.clearSelections();
					(winner === 'tie' ? dom.tie : dom[winner]).classList.add('selected');
					setTimeout(()=>{
						if (dom.battleSection.classList.contains('hidden') || !this.busy)
							return;
						this.busy = false;
						this.next();
					}
					, 300);
				}

				next() {
					this.clearSelections();
					const nextPair = this.provider.next(this);
					if (!nextPair)
						return this.renderResults();
					this.pair = nextPair;
					const key = this.provider.key(nextPair);
					this.swaps.has(key) || this.swaps.set(key, Math.random() < 0.5);
					this.swapped = this.swaps.get(key);
					let[a,b] = nextPair;
					this.swapped && ([a,b] = [b, a]);
					dom.left.textContent = this.items[a];
					dom.right.textContent = this.items[b];
					this.updateProgress();
				}

				updateProgress() {
					dom.progress.textContent = `${this.text('progress')}: ${this.provider ? this.provider.getProgress(this.step) : '0'}`;
				}
				clearSelections() {
					['left', 'right', 'tie'].forEach(id=>dom[id].classList.remove('selected'));
				}

				renderResults() {
					const results = this.provider.getResults(this.items, this.scores);
					dom.results.innerHTML = `<div class="results-header"><h2>${this.text('resultsTitle')}</h2></div><table><thead><tr><th style="width:20%">${this.text('rank')}</th><th style="width:60%">${this.text('item')}</th><th style="width:20%">${this.text('score')}</th></tr></thead><tbody>${results.map((result,index)=>`<tr><td>${index + 1}</td><td>${escape(result.text)}</td><td>${Math.round(result.score)}</td></tr>`).join('')}</tbody></table>`;
					this.show('results');
				}

				show(section) {
					['inputSection', 'battleSection', 'results'].forEach(id=>dom[id].classList.toggle('hidden', id !== section));
					dom.restartWrap.classList.toggle('hidden', section !== 'results');
					dom.undo.classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
					this.keyboardEnabled = section === 'battleSection' || section === 'results';
					section === 'battleSection' && dom.battleSection.parentNode.insertBefore(dom.undo, dom.battleSection);
					section === 'results' && dom.results.firstElementChild.prepend(dom.undo);
				}

				undo() {
					if (this.busy || !this.history.length)
						return;
					const last = this.history.pop();
					Object.assign(this, {
						scores: last.scores,
						step: last.step,
						pair: last.pair,
						swapped: last.swapped
					});
					this.provider.unmark(last.pair);
					let[a,b] = last.pair;
					this.swapped && ([a,b] = [b, a]);
					dom.left.textContent = this.items[a];
					dom.right.textContent = this.items[b];
					this.updateProgress();
					this.show('battleSection');
					dom.undo.disabled = !this.history.length;
				}

				reset() {
					Object.assign(this, {
						items: [],
						scores: [],
						pair: null,
						swapped: false,
						step: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						busy: false,
						provider: null,
						swaps: new Map()
					});
					dom.items.value = '';
					this.show('inputSection');
					this.updateHelp();
					this.updateProgress();
				}

				handleKey(event) {
					const actions = {
						ArrowLeft: 'left',
						ArrowRight: 'right',
						ArrowUp: 'tie',
						ArrowDown: 'tie',
						z: 'undo',
						Z: 'undo'
					};
					const action = actions[event.key];
					const isUndo = event.key.toLowerCase() === 'z';
					const isTie = event.key === 'ArrowUp' || event.key === 'ArrowDown';
					const blocked = !this.keyboardEnabled || ['SELECT', 'INPUT', 'TEXTAREA'].includes(document.activeElement.tagName) || !action || (isUndo && ((!event.ctrlKey && !event.metaKey) || event.shiftKey)) || (isTie && !this.allowTies) || (!isUndo && dom.battleSection.classList.contains('hidden'));
					blocked || (event.preventDefault(),
					dom[action].click());
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
