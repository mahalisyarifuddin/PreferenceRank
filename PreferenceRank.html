<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>PreferenceRank</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
		}
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
			transition: background-color .3s,
			color .3s,
			border-color .3s,
			outline-color .3s;
		}
		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 720px;
			padding: 2rem;
			width: 100%;
			position: relative;
		}
		.hidden {
			display: none !important;
		}
		h1, h2, label {
			margin: .5rem 0;
			display: block;
		}
		label {
			font-weight: 700;
		}
		input, select, textarea, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font: 1rem sans-serif;
			padding: .5rem;
			width: 100%;
		}
		input:focus-visible, select:focus-visible, textarea:focus-visible, button:focus-visible {
			outline: 2px solid var(--primary);
			outline-offset: 2px;
		}
		textarea {
			font-family: monospace;
			min-height: 80px;
			resize: vertical;
		}
		button {
			cursor: pointer;
			transition: background .1s;
		}
		button:disabled {
			background: var(--muted) !important;
			cursor: not-allowed;
			opacity: .6;
		}
		.primary {
			background: var(--primary);
			border: none;
			color: var(--on-primary);
		}
		.primary:hover:not(:disabled) {
			background: var(--hover);
		}
		.secondary:hover:not(:disabled) {
			background: var(--muted);
		}
		.count {
			font-size: .85rem;
			margin-top: .25rem;
			text-align: right;
			opacity: .8;
		}
		.error {
			color: var(--danger);
			font-size: .9rem;
			margin-top: .5rem;
			display: block;
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
		}
		.selectors select {
			width: auto;
			font-size: .9rem;
		}
		.row {
			display: flex;
			align-items: center;
			gap: 10px;
			margin: .75rem 0;
		}
		.row input {
			width: auto;
		}
		.row label {
			margin: 0;
		}
		.actions {
			display: flex;
			flex-direction: column;
			gap: 10px;
			margin-top: 1rem;
		}
		#battle, #tieWrap, #restartWrap {
			display: flex;
			gap: 1rem;
			margin-top: 1rem;
		}
		#battle button, #tieWrap button {
			flex: 1;
			font-size: 1.2rem;
			min-height: 100px;
		}
		#progress {
			font-size: 1.1rem;
			margin-top: 1rem;
			text-align: center;
		}
		.track {
			background: var(--muted);
			border-radius: 4px;
			height: 6px;
			margin: 8px auto 0;
			max-width: 200px;
			overflow: hidden;
		}
		.fill {
			background: var(--primary);
			height: 100%;
			width: 0;
		}
		#tips {
			background: var(--background);
			border: 1px solid var(--border);
			border-radius: 4px;
			font-size: .85rem;
			line-height: 1.5;
			margin-top: 15px;
			opacity: .9;
			padding: 8px;
			text-align: center;
		}
		#results {
			overflow-x: auto;
		}
		kbd {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 3px;
			box-shadow: 0 1px 1px #0003;
			display: inline-block;
			font-family: monospace;
			font-size: .9em;
			margin: 0 3px;
			padding: 2px 5px;
		}
		#cancel, #toggle {
			background: none;
			border: 1px solid var(--border);
			color: var(--text);
			cursor: pointer;
			display: block;
			font-size: .9rem;
			margin: 1rem auto;
			padding: 5px 15px;
			width: auto;
		}
		#cancel:hover {
			background: var(--muted);
		}
		#cancel.confirming {
			border-color: var(--danger);
			color: var(--danger);
		}
		#toggle {
			border: none;
			color: var(--primary);
			text-decoration: underline;
		}
		.leaderboard {
			border: 1px solid var(--border);
			border-radius: 8px;
			background: var(--surface);
			overflow: hidden;
			margin-top: 1rem;
		}
		.lb-header {
			display: flex;
			padding: 1rem;
			background: var(--background);
			border-bottom: 1px solid var(--border);
			font-weight: 600;
			color: var(--text);
			font-size: .9rem;
		}
		.lb-header > div {
			cursor: pointer;
			user-select: none;
			display: flex;
			align-items: center;
			gap: .5rem;
		}
		.lb-header > div:hover {
			color: var(--primary);
		}
		.lb-row {
			border-bottom: 1px solid var(--border);
		}
		.lb-row:last-child {
			border-bottom: none;
		}
		.lb-main {
			display: flex;
			padding: 1rem;
			align-items: center;
			cursor: pointer;
			background: var(--surface);
		}
		.lb-main:hover {
			background: var(--muted);
		}
		.lb-col-rank {
			flex: 0 0 85px;
			display: flex;
			align-items: center;
			gap: 8px;
			font-weight: bold;
		}
		.lb-col-item {
			flex: 1;
			font-weight: 500;
		}
		.lb-col-score {
			flex: 0 0 120px;
			text-align: right;
			font-variant-numeric: tabular-nums;
		}
		.lb-details {
			display: none;
			background: var(--background);
			padding: 1rem 1rem 1rem calc(1rem + 85px);
			border-top: 1px solid var(--border);
			font-size: .9rem;
		}
		.lb-row.expanded .lb-details {
			display: block;
		}
		.lb-row.expanded .chevron {
			transform: rotate(90deg);
		}
		.chevron {
			display: inline-block;
			transition: transform .2s;
			font-size: .8rem;
			color: var(--text);
			opacity: .6;
		}
		.detail-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 1.5rem;
		}
		.detail-item {
			display: flex;
			flex-direction: column;
			gap: .25rem;
		}
		.detail-label {
			font-size: .75rem;
			color: var(--text);
			opacity: .7;
			font-weight: 600;
		}
		.detail-value {
			font-size: 1.1rem;
			font-weight: 500;
		}
		.ci-badge {
			color: var(--text);
			opacity: .6;
			font-size: .85rem;
			margin-left: 4px;
		}
		@media (max-width: 600px) {
			.lb-header, .lb-main {
				padding: .75rem;
			}
			.lb-col-rank { flex: 0 0 60px; }
			.lb-col-score { flex: 0 0 90px; }
			.lb-details { padding-left: 1rem; }
		}
		.header {
			display: flex;
			justify-content: center;
			align-items: center;
			position: relative;
			min-height: 40px;
			margin-bottom: 1rem;
		}
		.header #undo {
			position: absolute;
			left: 0;
			top: 50%;
			transform: translateY(-50%);
		}
		.header #copy {
			position: absolute;
			right: 0;
			top: 50%;
			transform: translateY(-50%);
		}
		#undo, #copy {
			width: auto;
		}
		.selected {
			background: var(--primary) !important;
			color: var(--on-primary) !important;
		}
		@media (max-width: 768px) {
			body {
				padding: .75rem;
			}
			.container {
				padding: 1.5rem;
			}
			.selectors {
				position: static;
				justify-content: flex-end;
				margin-bottom: .5rem;
			}
			#battle, #tieWrap, #restartWrap {
				flex-direction: column;
			}
		}
		#sessionModal {
			position: absolute;
			inset: 0; background:
			var(--surface);
			z-index: 10;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			padding: 2rem;
			text-align: center;
		}
		#sessionButtons {
			display: flex;
			gap: 1rem;
			width: 100%;
			max-width: 400px;
		}
		#sessionButtons button {
			flex: 1;
		}
		.visually-hidden {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0, 0, 0, 0);
			white-space: nowrap;
			border: 0;
		}
		.spread-track {
			background: var(--muted);
			border-radius: 2px;
			height: 4px;
			margin-top: 4px;
			overflow: hidden;
			position: relative;
			width: 100%;
		}
		.spread-bar {
			background: var(--primary);
			height: 100%;
			min-width: 2px;
			position: absolute;
		}
	</style>
</head>
<body>
	<div class="container">
		<div id="sessionModal" class="hidden" role="dialog" aria-modal="true">
			<h2 id="sessionTitle"></h2>
			<p id="sessionMessage" style="margin:1rem 0 2rem;line-height:1.5"></p>
			<div id="sessionButtons">
				<button id="sessionContinue" class="primary"></button>
				<button id="sessionNew" class="secondary"></button>
			</div>
		</div>
		<div id="inputSection">
			<div class="selectors">
				<select id="language" aria-label="Language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
				<select id="theme" aria-label="Theme"><option value="auto"></option><option value="light"></option><option value="dark"></option></select>
			</div>
			<h1 id="title"></h1>
			<div class="group">
				<label for="items" id="labelItems"></label>
				<textarea id="items" rows="5" spellcheck="false" autofocus aria-describedby="error"></textarea>
				<div id="itemCount" class="count"></div>
				<span id="error" class="error hidden" aria-live="polite"></span>
			</div>
			<div class="row"><input type="checkbox" id="allowTies"><label for="allowTies" id="labelTies"></label></div>
			<div class="row"><input type="checkbox" id="quickRank"><label for="quickRank" id="labelQuick"></label></div>
			<div class="actions">
				<button id="resume" class="primary hidden"></button>
				<button id="start" class="primary"></button>
			</div>
		</div>
		<div id="announcer" class="visually-hidden" aria-live="polite"></div>
		<button id="undo" class="secondary hidden" disabled></button>
		<button id="copy" class="secondary hidden"></button>
		<div id="battleSection" class="hidden">
			<div id="battle">
				<button id="left" class="secondary"></button>
				<button id="right" class="secondary"></button>
			</div>
			<div id="tieWrap" class="hidden"><button id="tie" class="secondary"></button></div>
			<div id="progress"></div>
			<div id="progressTrack" class="track" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div id="progressFill" class="fill"></div></div>
			<button id="cancel"></button>
			<button id="toggle"></button>
			<div id="tips" class="hidden"></div>
		</div>
		<div id="results" class="hidden"></div>
		<div id="restartWrap" class="hidden">
			<button id="restartBattle" class="primary"></button>
			<button id="restartNew" class="primary"></button>
		</div>
	</div>
	<script>
		try{const d=JSON.parse(localStorage.getItem('preferenceRankData'));d?.settings?.theme&&d.settings.theme!=='auto'&&(document.documentElement.className=d.settings.theme)}catch(e){}

		const text = {
			en: {
				title: 'PreferenceRank',
				languageLabel: 'Language',
				themeLabel: 'Theme',
				autoTheme: 'Auto Theme',
				lightTheme: 'Light',
				darkTheme: 'Dark',
				labelItems: 'Enter items, one per line:',
				labelTies: 'Allow Ties',
				labelQuick: 'Use Quick Rank (fewer comparisons)',
				duplicate: '{count} duplicate item(s) removed.',
				itemsCount: '{count} items',
				start: 'Start Ranking',
				resume: 'Resume Ranking',
				cancel: 'Cancel',
				confirmCancel: 'Confirm Cancel?',
				tie: "It's a Tie",
				undo: 'Undo',
				progress: 'Progress',
				toggleShow: 'Show keyboard shortcuts',
				toggleHide: 'Hide keyboard shortcuts',
				shortcutLeft: 'Left Arrow',
				shortcutRight: 'Right Arrow',
				shortcutTie: 'Up/Down Arrow',
				shortcutUndo: 'Ctrl/⌘ + Z',
				tipTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>↑</kbd>/<kbd>↓</kbd> Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
				tipNoTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
				resultsTitle: 'Results',
				rank: 'Rank',
				item: 'Item',
				score: 'Score',
				compare: 'Compare: {1} vs {2}',
				resultsReady: 'Ranking complete. Results table is shown.',
				restartBattle: 'Restart Battle',
				restartNew: 'Edit Items',
				placeholderItems: 'Apple\nBlueberry\nCherry',
				copy: 'Copy Results',
				copied: 'Copied!',
				resumeTitle: 'Resume Session?',
				resumeMessage: 'A previous ranking session was found. Do you want to continue where you left off?',
				resumeConfirm: 'Continue',
				resumeNew: 'New Session',
				estMatches: ' (~{count} comparisons)',
				rankSpread: 'Rank Spread',
				matches: 'Matches',
				ci: 'CI (±)',
				filter: 'Filter items...'
			},
			id: {
				title: 'PreferenceRank',
				languageLabel: 'Bahasa',
				themeLabel: 'Tema',
				autoTheme: 'Tema Otomatis',
				lightTheme: 'Terang',
				darkTheme: 'Gelap',
				labelItems: 'Masukkan pilihan, satu per baris:',
				labelTies: 'Izinkan Seri',
				labelQuick: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
				duplicate: '{count} item duplikat dihapus.',
				itemsCount: '{count} pilihan',
				start: 'Mulai Peringkat',
				resume: 'Lanjutkan Peringkat',
				cancel: 'Batal',
				confirmCancel: 'Konfirmasi Batal?',
				tie: 'Seri',
				undo: 'Urungkan',
				progress: 'Kemajuan',
				toggleShow: 'Tampilkan pintasan papan ketik',
				toggleHide: 'Sembunyikan pintasan papan ketik',
				shortcutLeft: 'Panah Kiri',
				shortcutRight: 'Panah Kanan',
				shortcutTie: 'Panah Atas/Bawah',
				shortcutUndo: 'Ctrl/⌘ + Z',
				tipTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>↑</kbd>/<kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
				tipNoTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
				resultsTitle: 'Hasil',
				rank: 'Peringkat',
				item: 'Nama',
				score: 'Skor',
				compare: 'Bandingkan: {1} lawan {2}',
				resultsReady: 'Peringkat selesai. Tabel hasil ditampilkan.',
				restartBattle: 'Mulai Ulang Pertarungan',
				restartNew: 'Ubah Pilihan',
				placeholderItems: 'Apel\nBluberi\nCeri',
				copy: 'Salin Hasil',
				copied: 'Disalin!',
				resumeTitle: 'Lanjutkan Sesi?',
				resumeMessage: 'Sesi peringkat sebelumnya ditemukan. Apakah Anda ingin melanjutkannya?',
				resumeConfirm: 'Lanjutkan',
				resumeNew: 'Sesi Baru',
				estMatches: ' (~{count} perbandingan)',
				rankSpread: 'Rentang Peringkat',
				matches: 'Pertandingan',
				ci: 'IK (±)',
				filter: 'Cari pilihan...'
			}
		};
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

		const Matrix = {
			zeros: (r, c) => Array.from({ length: r }, () => Array(c).fill(0)),
			identity: (n) => Array.from({ length: n }, (_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0)),
			multiply: (A, B) => {
				const rA = A.length, cA = A[0].length, rB = B.length, cB = B[0].length;
				if (cA !== rB) throw new Error('Dimension mismatch');
				const C = Matrix.zeros(rA, cB);
				for (let i = 0; i < rA; i++) for (let j = 0; j < cB; j++) for (let k = 0; k < cA; k++) C[i][j] += A[i][k] * B[k][j];
				return C;
			},
			cholesky: (A) => {
				const n = A.length, L = Matrix.zeros(n, n);
				for (let i = 0; i < n; i++) {
					for (let j = 0; j <= i; j++) {
						let sum = 0;
						for (let k = 0; k < j; k++) sum += L[i][k] * L[j][k];
						if (i === j) {
							const val = A[i][i] - sum;
							if (val <= 0) return null;
							L[i][j] = Math.sqrt(val);
						} else L[i][j] = (1 / L[j][j] * (A[i][j] - sum));
					}
				}
				return L;
			},
			inverse: (A) => {
				const n = A.length, M = A.map(row => [...row]), I = Matrix.identity(n);
				for (let i = 0; i < n; i++) {
					let pivot = M[i][i], k = i;
					if (Math.abs(pivot) < 1e-10) {
						k = i + 1;
						while (k < n && Math.abs(M[k][i]) < 1e-10) k++;
						if (k == n) return null;
						[M[i], M[k]] = [M[k], M[i]];
						[I[i], I[k]] = [I[k], I[i]];
						pivot = M[i][i];
					}
					const invPivot = 1 / pivot;
					for (let j = 0; j < n; j++) { M[i][j] *= invPivot; I[i][j] *= invPivot; }
					for (let l = 0; l < n; l++) {
						if (l !== i) {
							const f = M[l][i];
							for (let j = 0; j < n; j++) { M[l][j] -= f * M[i][j]; I[l][j] -= f * I[i][j]; }
						}
					}
				}
				return I;
			}
		};

		class Stats {
			static calculate(items, matches, scores) {
				const N = items.length;
				if (N < 2) return null;
				const factor = Math.log(10) / 400;
				const theta = scores.map(s => s * factor);
				const H = Matrix.zeros(N, N), n_matches = Matrix.zeros(N, N);
				matches.forEach(m => { n_matches[m.a][m.b]++; n_matches[m.b][m.a]++; });
				for (let i = 0; i < N; i++) {
					for (let j = i + 1; j < N; j++) {
						if (n_matches[i][j] > 0) {
							const prob = 1 / (1 + Math.exp(-(theta[i] - theta[j])));
							const weight = n_matches[i][j] * prob * (1 - prob);
							H[i][j] = -weight; H[j][i] = -weight; H[i][i] += weight; H[j][j] += weight;
						}
					}
				}
				const subH = H.slice(0, N - 1).map(row => row.slice(0, N - 1));
				for (let i = 0; i < N - 1; i++) subH[i][i] += 1e-9;
				const invSubH = Matrix.inverse(subH);
				if (!invSubH) return null;
				const Cov = Matrix.zeros(N, N);
				for (let i = 0; i < N - 1; i++) for (let j = 0; j < N - 1; j++) Cov[i][j] = invSubH[i][j];
				const cis = [], multiplier = 0.11;
				for (let i = 0; i < N; i++) {
					let variance = 0, v = Array(N).fill(-1 / N); v[i] += 1;
					for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) variance += v[r] * Cov[r][c] * v[c];
					cis.push(multiplier * Math.sqrt(variance) / factor);
				}
				const L = Matrix.cholesky(invSubH);
				if (!L) return { cis, spreads: null };
				const ranks = Array.from({ length: N }, () => []), M = 500;
				let nextZ = null;
				const gaussian = () => {
					if (nextZ !== null) { const v = nextZ; nextZ = null; return v; }
					let u = 0, v = 0;
					while (u === 0) u = Math.random();
					while (v === 0) v = Math.random();
					const R = Math.sqrt(-2.0 * Math.log(u)), ang = 2.0 * Math.PI * v;
					nextZ = R * Math.sin(ang);
					return R * Math.cos(ang);
				};
				const N_1 = N - 1, Z = new Float64Array(N_1), delta = new Float64Array(N_1), sampleTheta = new Float64Array(N), indices = new Int32Array(N), sampleScores = new Float64Array(N);
				for (let k = 0; k < M; k++) {
					for (let i = 0; i < N_1; i++) Z[i] = gaussian();
					delta.fill(0);
					for (let i = 0; i < N_1; i++) {
						let s = 0; for (let j = 0; j <= i; j++) s += L[i][j] * Z[j];
						delta[i] = s * multiplier;
					}
					let sum = 0;
					for (let i = 0; i < N; i++) {
						const v = i < N_1 ? theta[i] + delta[i] : theta[i];
						sampleTheta[i] = v; sum += v;
					}
					const avg = sum / N;
					for (let i = 0; i < N; i++) {
						sampleScores[i] = 1000 + (sampleTheta[i] - avg) / factor;
						indices[i] = i;
					}
					indices.sort((a, b) => sampleScores[b] - sampleScores[a]);
					for (let i = 0; i < N; i++) ranks[indices[i]].push(i + 1);
				}
				const spreads = ranks.map(r => { r.sort((a, b) => a - b); return [r[Math.floor(M * 0.1)], r[Math.floor(M * 0.9)]]; });
				return { cis, spreads };
			}
		}

		class FullPairProvider {
			static estimate(count) { return count * (count - 1) / 2; }
			constructor(count) {
				this.pairs = [];
				for (let index = 0; index < count; index++) for (let j = index + 1; j < count; j++) this.pairs.push([index, j]);
				for (let index = this.pairs.length; index--;) {
					const j = Math.random() * (index + 1) | 0;
					[this.pairs[index], this.pairs[j]] = [this.pairs[j], this.pairs[index]];
				}
			}
			next(state) { return this.pairs[state.step]; }
			getProgress(state) { return `${state.step}/${this.pairs.length}`; }
		}

		class QuickPairProvider {
			static estimate(count) {
				if (count <= 1) return 0;
				if (count === 2) return 1;
				if (count === 3) return 3;
				// Improved estimation: n*log2(n) - n*0.91 + 2
				return Math.max(0, Math.round(count * Math.log2(count) - count * 0.91 + 2));
			}
			constructor(count) {
				this.count = count;
				this.stack = [{
					arr: Array.from({ length: count }, (_, i) => i),
					state: 0 // 0: initial, 1: left pushed, 2: right pushed, 3: merging
				}];
				this.history = [];
				this.pending = null;
			}
			
			snap() { 
				return {
					stack: structuredClone(this.stack),
					pending: this.pending,
					history: structuredClone(this.history)
				};
			}
			
			restore(snapshot) { 
				this.stack = structuredClone(snapshot.stack);
				this.pending = snapshot.pending;
				this.history = structuredClone(snapshot.history);
			}
			
			unmark(pair) { 
				if (this.history.length) {
					this.history.pop();
					if (this.history.length) {
						this.restore(this.history[this.history.length - 1]);
					}
				}
			}
			
			next(state, result) {
				if (this.pending && result !== undefined) {
					const frame = this.stack[this.stack.length - 1];
					if (frame && frame.state === 3 && frame.comparing) {
						const [a, b] = this.pending;
						const winner = result === 0.5 ? (state.swapped ? b : a) : result === 1 ? a : b;
						frame.lastWinner = winner;
						delete frame.comparing;
					}
					this.pending = null;
				}
				
				while (this.stack.length) {
					const frame = this.stack[this.stack.length - 1];
					
					if (frame.arr.length <= 1) {
						const value = frame.arr;
						this.stack.pop();
						if (this.stack.length) {
							const parent = this.stack[this.stack.length - 1];
							if (parent.state === 1) parent.left = value;
							else if (parent.state === 2) parent.right = value;
						}
						continue;
					}
					
					if (frame.state === 0) {
						frame.state = 1;
						const mid = frame.arr.length >> 1;
						this.stack.push({ arr: frame.arr.slice(0, mid), state: 0 });
						continue;
					}

					if (frame.state === 1) {
						frame.state = 2;
						const mid = frame.arr.length >> 1;
						this.stack.push({ arr: frame.arr.slice(mid), state: 0 });
						continue;
					}

					if (frame.state === 2) {
						frame.state = 3;
						frame.i = 0;
						frame.j = 0;
						frame.result = [];
					}

					if (frame.state === 3) {
						while (frame.i < frame.left.length && frame.j < frame.right.length) {
							if (frame.lastWinner !== undefined) {
								if (frame.lastWinner === frame.left[frame.i]) {
									frame.result.push(frame.left[frame.i]);
									frame.i++;
								} else {
									frame.result.push(frame.right[frame.j]);
									frame.j++;
								}
								delete frame.lastWinner;
							} else {
								this.pending = [frame.left[frame.i], frame.right[frame.j]];
								frame.comparing = true;
								this.history.push(this.snap());
								return this.pending;
							}
						}
						
						while (frame.i < frame.left.length) frame.result.push(frame.left[frame.i++]);
						while (frame.j < frame.right.length) frame.result.push(frame.right[frame.j++]);
						
						const value = frame.result;
						this.stack.pop();
						if (this.stack.length) {
							const parent = this.stack[this.stack.length - 1];
							if (parent.state === 1) parent.left = value;
							else if (parent.state === 2) parent.right = value;
						}
						continue;
					}
				}
				
				return null;
			}
			
			getProgress(step) { 
				return `${step}/~${Math.max(step, QuickPairProvider.estimate(this.count))}`;
			}
		}

		class PreferenceRank {
			constructor() {
				Object.assign(this, { scores: [], matches: [], history: [], swaps: {}, sortState: { column: 'rank', direction: 'asc' }, dirty: true });
				this.language = navigator.language.startsWith('id') ? 'id' : 'en';
				const events = {
					start: 'start', restartBattle: 'start', restartNew: 'reset', undo: 'undo',
					copy: 'copyResults', toggle: 'toggleHelp', cancel: 'cancel',
					sessionContinue: 'restoreSession', sessionNew: 'startNewSession', resume: 'resume'
				};
				Object.entries(events).forEach(([id, fn]) => elements[id].onclick = () => this[fn]());
				['left', 'right', 'tie'].forEach(id => elements[id].onclick = () => this.choose(id));
				elements.language.onchange = event => { this.lang(event.target.value); this.save(); };
				elements.theme.onchange = event => { this.theme(event.target.value); this.save(); };
				elements.allowTies.onchange = event => this.setTies(event.target.checked);
				elements.quickRank.onchange = () => this.updateInputState();
				elements.items.oninput = () => { this.updateInputState(); this.saveInput(); };
				elements.results.onclick = event => {
					const header = event.target.closest('.lb-header > div');
					if (header && header.dataset.sort) this.sortResults(header.dataset.sort);
				};
				elements.results.onkeydown = event => {
					if (event.key === 'Enter' || event.key === ' ') {
						const header = event.target.closest('.lb-header > div');
						if (header && header.dataset.sort) { event.preventDefault(); this.sortResults(header.dataset.sort); }
					}
				};
				document.onkeydown = event => this.key(event);
				this.theme('auto');
				this.lang(this.language);
				this.load();
			}

			string(key) { return text[this.language]?.[key] ?? key; }

			theme(themeName) { document.documentElement.className = themeName === 'auto' ? '' : themeName; elements.theme.value = themeName; }

			lang(language) {
				this.language = elements.language.value = language;
				elements.language.setAttribute('aria-label', this.string('languageLabel'));
				elements.theme.setAttribute('aria-label', this.string('themeLabel'));
				elements.items.placeholder = this.string('placeholderItems');
				['title', 'labelItems', 'labelTies', 'labelQuick', 'start', 'resume', 'cancel', 'tie', 'undo', 'copy', 'restartBattle', 'restartNew'].forEach(key => elements[key].textContent = this.string(key));
				elements.start.title = `${this.string('start')} (Ctrl/⌘ + Enter)`;
				elements.left.title = this.string('shortcutLeft');
				elements.right.title = this.string('shortcutRight');
				elements.tie.title = this.string('shortcutTie');
				elements.undo.title = `${this.string('undo')} (${this.string('shortcutUndo')})`;
				[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
				this.updateHelp();
				this.updateProgress();
				this.updateCount();
				if (!elements.results.classList.contains('hidden')) this.results();
			}

			save() {
				localStorage.setItem('preferenceRankData', JSON.stringify({
					inputValue: elements.items.value,
					settings: { theme: elements.theme.value, language: this.language },
					battle: this.provider ? { ...this, provider: this.provider, providerType: this.provider instanceof QuickPairProvider ? 'quick' : 'full' } : null
				}));
			}

			load() {
				try {
					const data = JSON.parse(localStorage.getItem('preferenceRankData'));
					if (data) {
						if (data.settings) { this.theme(data.settings.theme); this.lang(data.settings.language); }
						if (data.inputValue) { elements.items.value = data.inputValue; this.updateInputState(); }
						if (data.battle) data.battle.pair ? this.prompt(data.battle) : this.restoreBattle(data.battle);
						else this.display('inputSection');
					}
				} catch { localStorage.removeItem('preferenceRankData'); }
			}

			prompt(battle) {
				this.pending = battle;
				elements.sessionTitle.textContent = this.string('resumeTitle');
				elements.sessionMessage.textContent = this.string('resumeMessage');
				elements.sessionContinue.textContent = this.string('resumeConfirm');
				elements.sessionNew.textContent = this.string('resumeNew');
				elements.sessionModal.classList.remove('hidden');
				elements.inputSection.classList.add('hidden');
				elements.sessionContinue.focus();
			}

			restoreSession() {
				elements.sessionModal.classList.add('hidden');
				this.pending && this.restoreBattle(this.pending);
				this.pending = null;
			}

			startNewSession() {
				elements.sessionModal.classList.add('hidden');
				this.pending = null;
				elements.items.value = '';
				elements.allowTies.checked = false;
				elements.quickRank.checked = false;
				this.updateInputState();
				this.reset();
			}

			restoreBattle(battle) {
				Object.assign(this, battle);
				this.scores = Object.values(battle.scores);
				this.provider = new (battle.providerType === 'quick' ? QuickPairProvider : FullPairProvider)(this.items.length);
				if (!(battle.providerType === 'quick' && battle.provider.stack?.[0]?.type)) Object.assign(this.provider, battle.provider);
				elements.allowTies.checked = this.allowTies;
				elements.quickRank.checked = battle.providerType === 'quick';
				this.setTies(this.allowTies);
				this.pair ? (this.display('battleSection'), this.render(), this.updateProgress(), elements.undo.disabled = !this.history.length) : this.matches.length ? this.results() : this.display('inputSection');
			}

			saveInput() { clearTimeout(this.saveTimeout); this.saveTimeout = setTimeout(() => this.save(), 500); }

			getItems() {
				const lines = elements.items.value.split('\n').map(line => line.trim()).filter(Boolean);
				if (!lines.length) return [];
				const patterns = [/^\d+[\.\)]\s+/, /^[-*•]\s+/];
				return lines.map(line => {
					const pattern = patterns.find(p => p.test(line));
					return pattern ? line.replace(pattern, '') : line;
				});
			}

			updateInputState() {
				const items = this.getItems();
				this.check(items);
				this.updateCount(items);
			}

			updateCount(items) {
				const list = items || this.getItems();
				const count = list.length;
				const type = elements.quickRank.checked ? QuickPairProvider : FullPairProvider;
				elements.itemCount.textContent = this.string('itemsCount').replace('{count}', count) + this.string('estMatches').replace('{count}', type.estimate(count));
			}

			setTies(enabled) {
				this.allowTies = enabled;
				if (!elements.battleSection.classList.contains('hidden')) elements.tieWrap.classList.toggle('hidden', !enabled);
				this.updateHelp();
			}

			updateHelp() {
				const hidden = elements.tips.classList.contains('hidden');
				elements.toggle.textContent = this.string(hidden ? 'toggleShow' : 'toggleHide');
				elements.toggle.setAttribute('aria-expanded', !hidden);
				elements.tips.innerHTML = this.string(this.allowTies ? 'tipTie' : 'tipNoTie');
			}

			toggleHelp() { elements.tips.classList.toggle('hidden'); this.updateHelp(); }

			check(items) {
				const valid = new Set(items || this.getItems()).size >= 2;
				elements.start.disabled = !valid;
				if (valid) { elements.error.classList.add('hidden'); elements.items.removeAttribute('aria-invalid'); }
				elements.resume.classList.toggle('hidden', !this.provider);
			}

			start() {
				const raw = this.getItems();
				const unique = [...new Set(raw)];
				if (raw.length > unique.length) {
					elements.items.value = unique.join('\n');
					elements.error.textContent = this.string('duplicate').replace('{count}', raw.length - unique.length);
					elements.error.classList.remove('hidden');
					elements.items.setAttribute('aria-invalid', 'true');
					return;
				}
				elements.items.value = unique.join('\n');
				Object.assign(this, {
					items: unique,
					scores: Array(unique.length).fill(1e3),
					matches: [],
					pair: null,
					swapped: false,
					step: 0,
					allowTies: elements.allowTies.checked,
					history: [],
					busy: false,
					swaps: {},
					dirty: true
				});
				elements.undo.disabled = true;
				this.provider = new (elements.quickRank.checked ? QuickPairProvider : FullPairProvider)(unique.length);
				elements.tieWrap.classList.toggle('hidden', !this.allowTies);
				this.updateHelp();
				this.display('battleSection');
				this.next();
				this.save();
			}

			resume() { this.pair ? (this.display('battleSection'), this.render()) : this.results(); }

			recalculateScores() {
				if (!this.dirty && this.scores && this.scores.length === this.items.length) return;
				const n = this.items.length;
				const wins = Array(n).fill(0);
				const matchCount = Array.from({ length: n }, () => Array(n).fill(0));
				
				this.matches.forEach(({ a, b, result }) => {
					wins[a] += result;
					wins[b] += 1 - result;
					matchCount[a][b] += 1;
					matchCount[b][a] += 1;
				});
				
				// Bradley-Terry MM algorithm
				let strength = Array(n).fill(1);
				for (let iter = 0; iter < 50; iter++) {
					const newStrength = Array(n);
					let maxDiff = 0;
					
					for (let i = 0; i < n; i++) {
						let denom = 0;
						for (let j = 0; j < n; j++) {
							if (i !== j && matchCount[i][j] > 0) {
								denom += matchCount[i][j] / (strength[i] + strength[j]);
							}
						}
						newStrength[i] = denom > 0 ? (wins[i] + 0.5) / denom : strength[i];
						maxDiff = Math.max(maxDiff, Math.abs(newStrength[i] - strength[i]));
					}
					
					strength = newStrength;
					if (maxDiff < 1e-6) break;
				}
				
				// Convert to Elo scale
				const logs = strength.map(s => Math.log(Math.max(s, 1e-10)));
				const avg = logs.reduce((a, b) => a + b, 0) / n;
				this.scores = logs.map(v => 1000 + 400 * (v - avg) / Math.log(10));
				this.dirty = false;
			}

			choose(winner) {
				if (this.busy || elements.battleSection.classList.contains('hidden')) return;
				this.busy = true;
				this.history.push({ pair: this.pair, step: this.step, swapped: this.swapped });
				const [a, b] = this.pair;
				const result = winner === 'tie' ? .5 : +(winner === (this.swapped ? 'right' : 'left'));
				this.matches.push({ a, b, result });
				this.dirty = true;
				this.step++;
				elements.undo.disabled = false;
				this.updateProgress();
				this.clear();
				(winner === 'tie' ? elements.tie : elements[winner]).classList.add('selected');
				setTimeout(() => (!elements.battleSection.classList.contains('hidden') && this.busy && (this.busy = false, this.next(result), this.save())), 150);
			}

			next(result) {
				this.clear();
				const nextPair = this.provider.next(this, result);
				if (!nextPair) return this.pair = null, this.results();
				this.pair = nextPair;
				this.swapped = this.swaps[[...nextPair].sort().join('-')] ??= Math.random() < .5;
				this.render();
			}

			render() {
				let [a, b] = this.pair;
				if (this.swapped) [a, b] = [b, a];
				elements.left.textContent = this.items[a];
				elements.right.textContent = this.items[b];
				this.updateProgress();
				elements.announcer.textContent = this.string('compare').replace('{1}', this.items[a]).replace('{2}', this.items[b]);
			}

			updateProgress() {
				const progress = this.provider ? this.provider.getProgress(this.step) : '0/0';
				elements.progress.textContent = `${this.string('progress')}: ${progress}`;
				const [current, total] = progress.split('/');
				const percent = Math.min(100, Math.max(0, parseInt(total.replace('~', '')) > 0 ? parseInt(current) / parseInt(total.replace('~', '')) * 100 : 0));
				elements.progressFill.style.width = `${percent}%`;
				elements.progressTrack.setAttribute('aria-valuenow', Math.round(percent));
			}

			clear() { ['left', 'right', 'tie'].forEach(id => elements[id].classList.remove('selected')); }

			filterResults(term) {
				this.filterTerm = term;
				const lower = term.toLowerCase();
				const rows = elements.results.querySelectorAll('.lb-row');
				rows.forEach(row => {
					const text = row.querySelector('.lb-col-item').textContent.toLowerCase();
					row.classList.toggle('hidden', !text.includes(lower));
				});
			}

			sortResults(column) {
				const direction = this.sortState.column === column && this.sortState.direction === 'asc' ? 'desc' : 'asc';
				this.sortState = { column, direction };
				this.results();
			}

			results() {
				const dirty = this.dirty;
				this.recalculateScores();
				elements.results.parentElement.append(elements.undo, elements.copy);
				const baseRanking = [...this.scores.keys()].sort((a, b) => this.scores[b] - this.scores[a]);
				const ranks = []; baseRanking.forEach((x, index) => ranks[x] = index + 1);
				if (dirty || !this.stats) {
					this.stats = this.provider instanceof FullPairProvider ? null : Stats.calculate(this.items, this.matches, this.scores);
				}
				const sortDir = this.sortState.direction === 'asc' ? 1 : -1;
				const sorters = {
					rank: (a, b) => (this.scores[b] - this.scores[a]) * sortDir,
					rankSpread: (a, b) => this.stats && this.stats.spreads ? (this.stats.spreads[a][0] - this.stats.spreads[b][0] || this.stats.spreads[a][1] - this.stats.spreads[b][1]) * sortDir : 0,
					item: (a, b) => this.items[a].localeCompare(this.items[b]) * sortDir,
					score: (a, b) => (this.scores[a] - this.scores[b]) * sortDir,
					ci: (a, b) => this.stats && this.stats.cis ? (this.stats.cis[a] - this.stats.cis[b]) * sortDir : 0
				};
				this.currentRanking = [...this.scores.keys()].sort(sorters[this.sortState.column] || sorters.rank);
				const ranking = this.currentRanking;

				elements.results.innerHTML = '';
				const headerWrapper = document.createElement('div');
				headerWrapper.className = 'header';
				headerWrapper.innerHTML = `<h2>${this.string('resultsTitle')}</h2>`;
				headerWrapper.appendChild(elements.undo);
				headerWrapper.appendChild(elements.copy);
				elements.results.appendChild(headerWrapper);

				const filterDiv = document.createElement('div');
				filterDiv.style.cssText = "margin-bottom:.5rem;text-align:right";
				filterDiv.innerHTML = `<input type="search" id="resultFilter" placeholder="${this.string('filter')}" value="${this.filterTerm || ''}" style="width:200px;font-size:.9rem;padding:6px">`;
				elements.results.appendChild(filterDiv);

				const arrow = this.sortState.direction === 'asc' ? ' ▲' : ' ▼';
				const getSortIcon = (col) => this.sortState.column === col ? arrow : '';
				const getSortState = (col) => this.sortState.column === col ? (this.sortState.direction === 'asc' ? 'ascending' : 'descending') : 'none';

				const lb = document.createElement('div');
				lb.className = 'leaderboard';
				lb.setAttribute('role', 'table');
				lb.innerHTML = `
					<div class="lb-header" role="row">
						<div class="lb-col-rank" role="columnheader" tabindex="0" aria-sort="${getSortState('rank')}" data-sort="rank">${this.string('rank')}${getSortIcon('rank')}</div>
						<div class="lb-col-item" role="columnheader" tabindex="0" aria-sort="${getSortState('item')}" data-sort="item">${this.string('item')}${getSortIcon('item')}</div>
						<div class="lb-col-score" role="columnheader" tabindex="0" aria-sort="${getSortState('score')}" data-sort="score" style="justify-content: flex-end;">${this.string('score')}${getSortIcon('score')}</div>
					</div>
					<div class="lb-body" role="rowgroup"></div>
				`;
				const body = lb.querySelector('.lb-body');
				const hasStats = this.stats && this.stats.spreads;

				const itemMatches = Array(this.items.length).fill(0);
				this.matches.forEach(m => { itemMatches[m.a]++; itemMatches[m.b]++; });

				ranking.forEach(x => {
					const row = document.createElement('div');
					row.className = 'lb-row';
					const rank = ranks[x];
					const item = this.items[x];
					const score = Math.round(this.scores[x]);
					const ci = hasStats ? Math.round(this.stats.cis[x]) : null;
					const spread = hasStats ? `${this.stats.spreads[x][0]} - ${this.stats.spreads[x][1]}` : null;
					let spreadBar = '';
					if (hasStats) {
						// Calculate the visual representation of the rank spread
						const [min, max] = this.stats.spreads[x];
						const total = this.items.length;
						// Position and width are percentages of the total range
						const pMin = total > 1 ? ((min - 1) / (total - 1)) * 100 : 0;
						const pWidth = total > 1 ? ((max - min) / (total - 1)) * 100 : 100;
						spreadBar = `<div class="spread-track" title="${spread}"><div class="spread-bar" style="left:${pMin}%;width:${pWidth}%"></div></div>`;
					}

					row.innerHTML = `
						<div class="lb-main" role="button" tabindex="0">
							<div class="lb-col-rank">
								<span class="chevron">›</span>
								<span>${rank}</span>
							</div>
							<div class="lb-col-item">${new Option(item).innerHTML}</div>
							<div class="lb-col-score">
								${score}
								${ci !== null ? `<span class="ci-badge">±${ci}</span>` : ''}
							</div>
						</div>
						<div class="lb-details">
							<div class="detail-grid">
								${spread ? `
								<div class="detail-item">
									<span class="detail-label">${this.string('rankSpread')}</span>
									<span class="detail-value">${spread}</span>
									${spreadBar}
								</div>` : ''}
								<div class="detail-item">
									<span class="detail-label">${this.string('matches')}</span>
									<span class="detail-value">${itemMatches[x]}</span>
								</div>
							</div>
						</div>
					`;
					const main = row.querySelector('.lb-main');
					const toggle = () => row.classList.toggle('expanded');
					main.onclick = toggle;
					main.onkeydown = (e) => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }};
					body.appendChild(row);
				});
				elements.results.appendChild(lb);

				elements.resultFilter = document.getElementById('resultFilter');
				elements.resultFilter.oninput = event => this.filterResults(event.target.value);
				if (this.filterTerm) this.filterResults(this.filterTerm);

				this.display('results');
				elements.announcer.textContent = this.string('resultsReady');
				this.save();
			}

			display(section) {
				['inputSection', 'battleSection', 'results'].forEach(id => elements[id].classList.toggle('hidden', id !== section));
				elements.restartWrap.classList.toggle('hidden', section !== 'results');
				elements.undo.classList.toggle('hidden', section === 'inputSection');
				elements.copy.classList.toggle('hidden', section !== 'results');
				if (section === 'battleSection') elements.battleSection.before(elements.undo);
				if (section === 'results') { elements.results.firstChild.prepend(elements.undo); elements.results.firstChild.appendChild(elements.copy); }
				if (section === 'inputSection') this.check();
				const focusTarget = { battleSection: elements.left, results: elements.restartBattle, inputSection: elements.items }[section];
				focusTarget && setTimeout(() => focusTarget.focus(), 50);
			}

			copyResults() {
				const baseRanking = [...this.scores.keys()].sort((a, b) => this.scores[b] - this.scores[a]);
				const ranks = []; baseRanking.forEach((x, index) => ranks[x] = index + 1);
				const ranking = this.currentRanking || baseRanking;
				const hasStats = this.stats && this.stats.spreads;
				const headers = (hasStats ? ['rank', 'rankSpread', 'item', 'score', 'ci'] : ['rank', 'item', 'score']).map(k => this.string(k)).join('\t');
				const lines = ranking.map(x => {
					const row = [ranks[x]];
					if (hasStats) row.push(`${this.stats.spreads[x][0]}-${this.stats.spreads[x][1]}`);
					row.push(this.items[x], Math.round(this.scores[x]));
					if (hasStats) row.push(`±${Math.round(this.stats.cis[x])}`);
					return row.join('\t');
				});
				navigator.clipboard.writeText([headers, ...lines].join('\n')).then(() => {
					clearTimeout(this.copyTimeout);
					elements.copy.textContent = this.string('copied');
					elements.announcer.textContent = `${this.string('resultsTitle')} ${this.string('copied')}`;
					this.copyTimeout = setTimeout(() => elements.copy.textContent = this.string('copy'), 2e3);
				});
			}

			cancel() {
				const reset = () => { elements.cancel.classList.remove('confirming'); elements.cancel.textContent = this.string('cancel'); this.cancelTimeout = null; };
				this.cancelTimeout ? (clearTimeout(this.cancelTimeout), reset(), this.display('inputSection')) : (elements.cancel.textContent = this.string('confirmCancel'), elements.cancel.classList.add('confirming'), this.cancelTimeout = setTimeout(reset, 3000));
			}

			undo() {
				if (!this.busy && this.history.length) {
					const last = this.history.pop();
					this.matches.pop();
					this.dirty = true;
					Object.assign(this, { step: last.step, pair: last.pair, swapped: last.swapped });
					this.provider.unmark?.(last.pair);
					this.render();
					this.display('battleSection');
					elements.undo.disabled = !this.history.length;
					this.save();
				}
			}

			reset() {
				Object.assign(this, { scores: [], matches: [], history: [], provider: null, dirty: true });
				this.display('inputSection');
				this.updateHelp();
				this.updateProgress();
				this.save();
			}

			key(event) {
				if (event.repeat) return;
				const { key, ctrlKey, metaKey, shiftKey } = event;
				if (key === 'Enter' && (ctrlKey || metaKey) && !elements.inputSection.classList.contains('hidden') && !elements.start.disabled) {
					event.preventDefault();
					elements.start.click();
					return;
				}
				const action = { arrowleft: 'left', arrowright: 'right', arrowup: 'tie', arrowdown: 'tie', z: 'undo', '?': 'toggle', '/': 'toggle' }[key.toLowerCase()];
				if (!action) return;
				if (!elements.inputSection.classList.contains('hidden')) return;
				if (/^(SELECT|INPUT|TEXTAREA)$/.test(document.activeElement.tagName)) return;
				if (action === 'undo') {
					if ((ctrlKey || metaKey) && !shiftKey) { event.preventDefault(); elements.undo.click(); }
				} else if (!elements.battleSection.classList.contains('hidden') && (action !== 'tie' || this.allowTies)) {
					event.preventDefault();
					elements[action].click();
				}
			}
		}
		new PreferenceRank();
	</script>
</body>
</html>
