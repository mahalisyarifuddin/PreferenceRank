<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>PreferenceRank</title>
        <style>
            :root {
                --primary: #0070ea;
                --primary-hover: #005bc0;
                --background: #f9f9ff;
                --surface: #fff;
                --text: #414754;
                --border: #c1c6d7;
                --hover: #d7d9e5
            }

            @media(prefers-color-scheme: dark) {
                :root:not(.light) {
                    --background:#10131b;
                    --surface: #181c23;
                    --text: #c1c6d7;
                    --border: #414754;
                    --hover: #10131b
                }
            }

            :root.dark {
                --background: #10131b;
                --surface: #181c23;
                --text: #c1c6d7;
                --border: #414754;
                --hover: #10131b
            }

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0
            }

            body {
                background: var(--background);
                color: var(--text);
                font-family: sans-serif;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                padding: 1rem
            }

            .container {
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 8px;
                max-width: 720px;
                padding: 2rem;
                width: 100%;
                position: relative
            }

            .hidden {
                display: none!important
            }

            h1,h2 {
                margin: .5rem 0
            }

            label {
                display: block;
                font-weight: 700;
                margin-bottom: .5rem
            }

            input,select,textarea,button {
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 4px;
                color: var(--text);
                font-size: 1rem;
                padding: .5rem;
                width: 100%
            }

            textarea {
                min-height: 80px;
                resize: vertical
            }

            button {
                cursor: pointer;
                transition: background .2s
            }

            .primary {
                background: var(--primary);
                border: none;
                color: #fff
            }

            .primary:hover {
                background: var(--primary-hover)
            }

            .secondary:hover {
                background: var(--hover)
            }

            .selectors {
                position: absolute;
                right: 2rem;
                top: 1rem;
                display: flex;
                gap: 8px
            }

            .selectors select {
                font-size: .9rem;
                padding: 5px;
                width: auto
            }

            .checkbox-container {
                display: flex;
                align-items: center;
                gap: 10px;
                margin: .75rem 0
            }

            .checkbox-container input {
                width: auto
            }

            .checkbox-container label {
                margin: 0
            }

            #battle,#tieContainer,#restartContainer {
                display: flex;
                gap: 1rem;
                margin-top: 1rem
            }

            #battle button,#tieContainer button,#restartContainer button {
                flex: 1
            }

            #battle button,#tieContainer button {
                font-size: 1.2rem;
                min-height: 100px
            }

            #progress {
                font-size: 1.1rem;
                margin-top: 1rem;
                text-align: center
            }

            #shortcutTip {
                background: var(--background);
                border: 1px solid var(--border);
                border-radius: 4px;
                font-size: .85rem;
                line-height: 1.5;
                margin-top: 15px;
                opacity: .9;
                padding: 8px;
                text-align: center
            }

            #shortcutTip kbd {
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 3px;
                box-shadow: 0 1px 1px rgba(0,0,0,.2);
                display: inline-block;
                font-family: monospace;
                font-size: .9em;
                margin: 0 3px;
                padding: 2px 5px
            }

            #cancel {
                background: none;
                border: 1px solid var(--border);
                color: var(--text);
                cursor: pointer;
                display: block;
                font-size: .9rem;
                margin: 1rem auto;
                padding: 5px 15px;
                width: auto
            }

            #cancel:hover {
                background: var(--hover)
            }

            #shortcutToggle {
                background: none;
                border: none;
                color: var(--primary);
                cursor: pointer;
                display: block;
                font-size: .85rem;
                margin: 10px auto 0;
                text-decoration: underline;
                width: auto
            }

            #results table {
                border-collapse: collapse;
                margin-top: 1rem;
                width: 100%
            }

            #results th,#results td {
                border: 1px solid var(--border);
                padding: .5rem;
                text-align: left
            }

            #results th {
                background: var(--primary);
                color: #fff
            }

            .results-header {
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative;
                min-height: 40px;
                margin-bottom: 1rem
            }

            .results-header h2 {
                margin: 0
            }

            .results-header #undo {
                position: absolute;
                left: 0;
                top: 50%;
                transform: translateY(-50%)
            }

            #undo {
                width: auto
            }

            #undo:disabled {
                background: var(--hover);
                cursor: not-allowed
            }

            .selected {
                background: var(--primary)!important;
                color: #fff!important
            }

            @media(max-width: 768px) {
                body {
                    padding:.75rem
                }

                .container {
                    padding: 1.5rem
                }

                .selectors {
                    position: static;
                    justify-content: flex-end;
                    margin-bottom: .5rem;
                    gap: 4px
                }

                .selectors select {
                    font-size: .8rem;
                    padding: 4px
                }

                #battle,#tieContainer,#restartContainer {
                    flex-direction: column
                }

                #battle button,#tieContainer button {
                    width: 100%
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="input">
                <div class="selectors">
                    <select id="language">
                        <option value="en">English</option>
                        <option value="id">Bahasa Indonesia</option>
                    </select>
                    <select id="theme">
                        <option value="auto"></option>
                        <option value="light"></option>
                        <option value="dark"></option>
                    </select>
                </div>
                <h1 id="title"></h1>
                <div class="group">
                    <label for="items" id="itemsLabel"></label>
                    <textarea id="items" rows="5" spellcheck="false"></textarea>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="allowTies">
                    <label for="allowTies" id="allowTiesLabel"></label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="quickRank">
                    <label for="quickRank" id="quickRankLabel"></label>
                </div>
                <button id="start" class="primary"></button>
            </div>
            <button id="undo" class="secondary hidden" disabled></button>
            <div id="battleSection" class="hidden">
                <div id="battle">
                    <button id="left" class="secondary"></button>
                    <button id="right" class="secondary"></button>
                </div>
                <div id="tieContainer" class="hidden">
                    <button id="tie" class="secondary"></button>
                </div>
                <div id="progress"></div>
                <button id="cancel"></button>
                <button id="shortcutToggle"></button>
                <div id="shortcutTip" class="hidden"></div>
            </div>
            <div id="results" class="hidden"></div>
            <div id="restartContainer" class="hidden">
                <button id="restartBattle" class="primary"></button>
                <button id="restartNew" class="primary"></button>
            </div>
        </div>
        <script>
            const text = {
                en: {
                    title: 'PreferenceRank',
                    autoTheme: 'Auto Theme',
                    lightTheme: 'Light',
                    darkTheme: 'Dark',
                    itemsLabel: 'Enter items, one per line:',
                    allowTiesLabel: 'Allow Ties',
                    quickRankLabel: 'Use Quick Rank (fewer comparisons)',
                    alert: 'Please enter at least two items.',
                    duplicateAlert: '{count} duplicate item(s) were found and have been removed.',
                    start: 'Start Ranking',
                    cancel: 'Cancel',
                    tie: "It's a Tie",
                    undo: 'Undo',
                    progress: 'Progress',
                    shortcutToggle: 'Show keyboard shortcuts',
                    shortcutHide: 'Hide keyboard shortcuts',
                    shortcutWithTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> / <kbd>↓</kbd> It\'s a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
                    shortcutNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
                    resultsTitle: 'Results',
                    rank: 'Rank',
                    item: 'Item',
                    score: 'Score',
                    restartBattle: 'Restart Battle',
                    restartNew: 'Start with New Items'
                },
                id: {
                    title: 'PreferenceRank',
                    autoTheme: 'Tema Otomatis',
                    lightTheme: 'Terang',
                    darkTheme: 'Gelap',
                    itemsLabel: 'Masukkan pilihan, satu per baris:',
                    allowTiesLabel: 'Izinkan Seri',
                    quickRankLabel: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
                    alert: 'Harap masukkan setidaknya dua pilihan.',
                    duplicateAlert: '{count} item duplikat ditemukan dan telah dihapus.',
                    start: 'Mulai Peringkat',
                    cancel: 'Batal',
                    tie: 'Seri',
                    undo: 'Urungkan',
                    progress: 'Kemajuan',
                    shortcutToggle: 'Tampilkan pintasan papan ketik',
                    shortcutHide: 'Sembunyikan pintasan papan ketik',
                    shortcutWithTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> / <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
                    shortcutNoTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
                    resultsTitle: 'Hasil',
                    rank: 'Peringkat',
                    item: 'Nama',
                    score: 'Skor',
                    restartBattle: 'Mulai Ulang Pertarungan',
                    restartNew: 'Mulai dengan Pilihan Baru'
                }
            };

            const el = (tag,props)=>Object.assign(document.createElement(tag), props);
            const escape = value=>el('p', {
                textContent: value
            }).innerHTML;

            class PairProvider {
                constructor(count) {
                    this.count = count;
                    this.compared = new Set();
                }
                key([a,b]) {
                    return `${Math.min(a, b)}-${Math.max(a, b)}`;
                }
                mark(pair) {
                    this.compared.add(this.key(pair));
                }
                unmark(pair) {
                    this.compared.delete(this.key(pair));
                }
                has(pair) {
                    return this.compared.has(this.key(pair));
                }
                getResults(items, scores) {
                    return items.map((item,i)=>({
                        item,
                        score: scores[i]
                    })).sort((a,b)=>b.score - a.score);
                }
                getProgressText(step) {
                    return `${step}`;
                }
            }

            class FullPairProvider extends PairProvider {
                constructor(count) {
                    super(count);
                    this.pairs = [];
                    for (let i = 0; i < count - 1; i++)
                        for (let j = i + 1; j < count; j++)
                            this.pairs.push([i, j]);
                    for (let i = this.pairs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.pairs[i],this.pairs[j]] = [this.pairs[j], this.pairs[i]];
                    }
                }
                next(state) {
                    return this.pairs[state.step];
                }
                total() {
                    return this.pairs.length;
                }
                getProgressText(step) {
                    return `${step}/${this.total()}`;
                }
            }

            class QuickPairProvider extends PairProvider {
                constructor(count) {
                    super(count);
                    this.stack = [{
                        stage: 0,
                        items: Array.from({
                            length: count
                        }, (_,i)=>i),
                        left: null,
                        right: null
                    }];
                    this.historyStack = [];
                    this.pendingPair = null;
                    this.previousScores = null;
                    this.finalResult = null;
                    this.refinePass = 0;
                    this.refineIndex = 0;
                    this.refineSwapped = false;
                    this.maxRefinePasses = 3;
                }

                snapshot() {
                    return JSON.stringify({
                        stack: this.stack,
                        pendingPair: this.pendingPair,
                        previousScores: this.previousScores,
                        compared: [...this.compared],
                        finalResult: this.finalResult,
                        refinePass: this.refinePass,
                        refineIndex: this.refineIndex,
                        refineSwapped: this.refineSwapped
                    });
                }

                restore(json) {
                    const d = JSON.parse(json);
                    Object.assign(this, {
                        stack: d.stack,
                        pendingPair: d.pendingPair,
                        previousScores: d.previousScores,
                        compared: new Set(d.compared),
                        finalResult: d.finalResult || null,
                        refinePass: d.refinePass || 0,
                        refineIndex: d.refineIndex || 0,
                        refineSwapped: d.refineSwapped || false
                    });
                }

                unmark(pair) {
                    if (this.pendingPair && this.historyStack.length > 0)
                        this.historyStack.pop();
                    if (this.historyStack.length > 0) {
                        this.restore(this.historyStack[this.historyStack.length - 1]);
                        this.pendingPair = pair;
                    }
                    super.unmark(pair);
                }

                next(state) {
                    if (!this.previousScores)
                        this.previousScores = [...state.scores];
                    if (this.pendingPair) {
                        const [a,b] = this.pendingPair;
                        const change = state.scores[a] - this.previousScores[a];
                        const expected = 1 / (1 + 10 ** ((this.previousScores[b] - this.previousScores[a]) / 400));
                        const result = (change / 32) + expected;
                        const winnerId = Math.abs(result - 0.5) < 0.01 ? a : result > 0.75 ? a : b;

                        if (this.stack.length > 0)
                            this.stack[this.stack.length - 1].mergeResult.push((winnerId === a ? this.stack[this.stack.length - 1].left : this.stack[this.stack.length - 1].right).shift());
                        if (this.finalResult && winnerId === b) {
                            [this.finalResult[this.refineIndex],this.finalResult[this.refineIndex + 1]] = [this.finalResult[this.refineIndex + 1], this.finalResult[this.refineIndex]];
                            this.refineSwapped = true;
                        }
                        if (this.finalResult)
                            this.refineIndex++;
                        this.pendingPair = null;
                        this.previousScores = [...state.scores];
                    }

                    while (this.stack.length > 0) {
                        const frame = this.stack[this.stack.length - 1];
                        if (frame.stage === 0) {
                            if (frame.items.length <= 1) {
                                this.popAndPass(frame.items);
                                continue;
                            }
                            const mid = Math.floor(frame.items.length / 2);
                            frame.stage = 1;
                            frame.leftItems = frame.items.slice(0, mid);
                            frame.rightItems = frame.items.slice(mid);
                            this.stack.push({
                                stage: 0,
                                items: frame.leftItems,
                                left: null,
                                right: null
                            });
                            continue;
                        }
                        if (frame.stage === 1) {
                            frame.stage = 2;
                            this.stack.push({
                                stage: 0,
                                items: frame.rightItems,
                                left: null,
                                right: null
                            });
                            continue;
                        }
                        if (frame.stage === 2) {
                            if (!frame.mergeResult) {
                                frame.mergeResult = [];
                                frame.left = [...frame.leftResult];
                                frame.right = [...frame.rightResult];
                            }
                            while (frame.left.length > 0 && frame.right.length > 0) {
                                const pair = [frame.left[0], frame.right[0]];
                                this.historyStack.push(this.snapshot());
                                this.pendingPair = pair;
                                return pair;
                            }
                            frame.mergeResult.push(...frame.left, ...frame.right);
                            this.popAndPass(frame.mergeResult);
                            continue;
                        }
                    }

                    if (this.finalResult) {
                        while (true) {
                            if (this.refinePass >= this.maxRefinePasses)
                                return null;
                            if (this.refineIndex >= this.finalResult.length - 1) {
                                if (!this.refineSwapped)
                                    return null;
                                this.refinePass++;
                                this.refineIndex = 0;
                                this.refineSwapped = false;
                                continue;
                            }
                            const [a,b] = [this.finalResult[this.refineIndex], this.finalResult[this.refineIndex + 1]];
                            if (this.has([a, b])) {
                                this.refineIndex++;
                                continue;
                            }
                            this.historyStack.push(this.snapshot());
                            this.pendingPair = [a, b];
                            return [a, b];
                        }
                    }
                    return null;
                }

                popAndPass(result) {
                    this.stack.pop();
                    if (this.stack.length > 0) {
                        const p = this.stack[this.stack.length - 1];
                        p.stage === 1 ? p.leftResult = result : p.rightResult = result;
                    } else
                        this.finalResult = result;
                }

                getResults(items, scores) {
                    if (!this.finalResult)
                        return super.getResults(items, scores);
                    const sorted = [...scores].sort((a,b)=>b - a);
                    return this.finalResult.map((idx,i)=>({
                        item: items[idx],
                        score: sorted[i]
                    }));
                }
            }

            class PreferenceRank {
                constructor() {
                    this.dom = Object.fromEntries([...document.querySelectorAll('[id]')].map(node=>[node.id, node]));
                    this.items = [];
                    this.scores = [];
                    this.pair = null;
                    this.swapped = false;
                    this.step = 0;
                    this.allowTies = false;
                    this.history = [];
                    this.keyboardEnabled = false;
                    this.isChoosing = false;
                    this.language = navigator.language?.startsWith('id') ? 'id' : 'en';
                    this.provider = null;
                    this.swaps = new Map();
                    this.init();
                }

                init() {
                    this.bind();
                    this.setTheme('auto');
                    this.setLanguage(this.language);
                    this.undoParent = this.dom.undo.parentNode;
                    this.undoSibling = this.dom.battleSection;
                }

                bind() {
                    const {dom} = this;
                    const on = (id,handler)=>dom[id].onclick = handler;
                    on('start', ()=>this.startRanking());
                    on('cancel', ()=>this.show('input'));
                    on('left', ()=>this.choose('left'));
                    on('right', ()=>this.choose('right'));
                    on('tie', ()=>this.choose('tie'));
                    on('restartBattle', ()=>this.restart());
                    on('restartNew', ()=>this.reset());
                    on('undo', ()=>this.undoChoice());
                    on('shortcutToggle', ()=>this.toggleShortcuts());
                    dom.language.onchange = e=>this.setLanguage(e.target.value);
                    dom.theme.onchange = e=>this.setTheme(e.target.value);
                    dom.allowTies.onchange = e=>this.setTies(e.target.checked);
                    document.onkeydown = e=>this.handleKey(e);
                }

                str(key) {
                    return text[this.language][key];
                }
                tpl(key, values) {
                    return Object.entries(values || {}).reduce((r,[k,v])=>r.replace(`{${k}}`, v), this.str(key));
                }

                setTheme(theme) {
                    document.documentElement.classList.remove('light', 'dark');
                    if (theme !== 'auto')
                        document.documentElement.classList.add(theme);
                    this.dom.theme.value = theme;
                }

                setLanguage(language) {
                    this.language = language;
                    this.dom.language.value = language;
                    document.documentElement.lang = language;
                    const {dom} = this
                      , src = text[language];
                    const set = ids=>ids.forEach(id=>dom[id].textContent = src[id]);
                    set(['title', 'itemsLabel', 'allowTiesLabel', 'quickRankLabel', 'start', 'cancel', 'tie', 'undo', 'restartBattle', 'restartNew']);
                    dom.theme.options[0].textContent = src.autoTheme;
                    dom.theme.options[1].textContent = src.lightTheme;
                    dom.theme.options[2].textContent = src.darkTheme;
                    this.updateShortcuts();
                    this.updateProgress();
                    if (!dom.results.classList.contains('hidden'))
                        this.showResults();
                }

                setTies(enabled) {
                    this.allowTies = enabled;
                    if (!this.dom.battleSection.classList.contains('hidden'))
                        this.dom.tieContainer.classList.toggle('hidden', !enabled);
                    this.updateShortcuts();
                }

                updateShortcuts() {
                    const hidden = this.dom.shortcutTip.classList.contains('hidden');
                    this.dom.shortcutToggle.textContent = hidden ? this.str('shortcutToggle') : this.str('shortcutHide');
                    this.dom.shortcutTip.innerHTML = this.str(this.allowTies ? 'shortcutWithTies' : 'shortcutNoTies');
                }

                toggleShortcuts(forceHide) {
                    const hide = typeof forceHide === 'boolean' ? forceHide : !this.dom.shortcutTip.classList.contains('hidden');
                    this.dom.shortcutTip.classList.toggle('hidden', hide);
                    this.updateShortcuts();
                }

                initBattle() {
                    this.scores = Array(this.items.length).fill(1000);
                    this.step = 0;
                    this.history = [];
                    this.swaps = new Map();
                    this.dom.undo.disabled = true;
                    this.provider = this.dom.quickRank.checked ? new QuickPairProvider(this.items.length) : new FullPairProvider(this.items.length);
                }

                startRanking() {
                    const raw = this.dom.items.value.split('\n').map(l=>l.trim()).filter(Boolean);
                    const unique = [...new Set(raw)];
                    const duplicates = raw.length - unique.length;
                    if (duplicates > 0)
                        alert(this.tpl('duplicateAlert', {
                            count: duplicates
                        }));
                    if (unique.length < 2)
                        return alert(this.str('alert'));

                    this.items = unique;
                    this.allowTies = this.dom.allowTies.checked;
                    this.initBattle();
                    this.dom.tieContainer.classList.toggle('hidden', !this.allowTies);
                    this.updateShortcuts();
                    this.show('battleSection');
                    this.nextBattle();
                }

                calcScores(winner) {
                    const [first,second] = this.pair;
                    const isFirst = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
                    const result = winner === 'tie' ? 0.5 : isFirst ? 1 : 0;
                    const expected = 1 / (1 + 10 ** ((this.scores[second] - this.scores[first]) / 400));
                    this.scores[first] += 32 * (result - expected);
                    this.scores[second] += 32 * (expected - result);
                }

                choose(winner) {
                    if (this.isChoosing || this.dom.battleSection.classList.contains('hidden'))
                        return;
                    this.isChoosing = true;
                    this.history.push({
                        pair: this.pair,
                        scores: [...this.scores],
                        step: this.step,
                        swapped: this.swapped
                    });
                    this.provider.mark(this.pair);
                    this.calcScores(winner);
                    this.step++;
                    this.dom.undo.disabled = false;
                    this.updateProgress();
                    this.clearSelections();

                    (winner === 'tie' ? this.dom.tie : this.dom[winner]).classList.add('selected');
                    setTimeout(()=>{
                        this.isChoosing = false;
                        this.nextBattle();
                    }
                    , 300);
                }

                displayBattle() {
                    this.clearSelections();
                    let[first,second] = this.pair;
                    if (this.swapped)
                        [first,second] = [second, first];
                    this.dom.left.textContent = this.items[first];
                    this.dom.right.textContent = this.items[second];
                    this.updateProgress();
                }

                nextBattle() {
                    this.clearSelections();
                    const next = this.provider.next(this);
                    if (!next)
                        return this.showResults();
                    this.pair = next;
                    const key = this.provider.key(next);
                    if (!this.swaps.has(key))
                        this.swaps.set(key, Math.random() < 0.5);
                    this.swapped = this.swaps.get(key);
                    this.displayBattle();
                }

                updateProgress() {
                    this.dom.progress.textContent = `${this.str('progress')}: ${this.provider ? this.provider.getProgressText(this.step) : '0'}`;
                }

                clearSelections() {
                    ['left', 'right', 'tie'].forEach(id=>this.dom[id].classList.remove('selected'));
                }

                showResults() {
                    const results = this.provider.getResults(this.items, this.scores);
                    this.dom.results.innerHTML = `<div class="results-header"><h2>${this.str('resultsTitle')}</h2></div>
				<table><thead><tr><th style="width:20%">${this.str('rank')}</th><th style="width:60%">${this.str('item')}</th><th style="width:20%">${this.str('score')}</th></tr></thead>
				<tbody>${results.map(r=>`<tr><td>${results.findIndex(x=>Math.round(x.score) === Math.round(r.score)) + 1}</td><td>${escape(r.item)}</td><td>${Math.round(r.score)}</td></tr>`).join('')}</tbody></table>`;
                    this.show('results');
                }

                show(section) {
                    ['input', 'battleSection', 'results'].forEach(id=>this.dom[id].classList.toggle('hidden', id !== section));
                    this.dom.restartContainer.classList.toggle('hidden', section !== 'results');
                    this.dom.undo.classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
                    this.keyboardEnabled = section === 'battleSection' || section === 'results';
                    if (section === 'battleSection')
                        this.undoParent.insertBefore(this.dom.undo, this.undoSibling);
                    else if (section === 'results')
                        this.dom.results.firstElementChild.prepend(this.dom.undo);
                }

                undoChoice() {
                    if (this.isChoosing || !this.history.length)
                        return;
                    const last = this.history.pop();
                    Object.assign(this, {
                        scores: last.scores,
                        step: last.step,
                        pair: last.pair,
                        swapped: last.swapped
                    });
                    this.provider.unmark(last.pair);
                    this.displayBattle();
                    this.show('battleSection');
                    this.dom.undo.disabled = !this.history.length;
                }

                restart() {
                    this.initBattle();
                    this.show('battleSection');
                    this.nextBattle();
                }

                reset() {
                    Object.assign(this, {
                        items: [],
                        scores: [],
                        pair: null,
                        swapped: false,
                        step: 0,
                        allowTies: false,
                        history: [],
                        keyboardEnabled: false,
                        isChoosing: false,
                        provider: null,
                        swaps: new Map()
                    });
                    this.dom.items.value = '';
                    this.dom.allowTies.checked = false;
                    this.dom.quickRank.checked = false;
                    this.show('input');
                    this.updateShortcuts();
                    this.updateProgress();
                }

                handleKey(event) {
                    if (!this.keyboardEnabled || ['SELECT', 'INPUT', 'TEXTAREA'].includes(document.activeElement.tagName))
                        return;
                    const map = {
                        ArrowLeft: 'left',
                        ArrowRight: 'right',
                        ArrowUp: 'tie',
                        ArrowDown: 'tie',
                        z: 'undo',
                        Z: 'undo'
                    };
                    const target = map[event.key];
                    if (!target)
                        return;

                    const isUndo = event.key === 'z' || event.key === 'Z';
                    const isArrow = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key);
                    if (isUndo && !(event.ctrlKey || event.metaKey))
                        return;
                    if (isUndo && event.shiftKey)
                        return;
                    if (isArrow && !this.allowTies && (event.key === 'ArrowUp' || event.key === 'ArrowDown'))
                        return;
                    if (isArrow && this.dom.battleSection.classList.contains('hidden'))
                        return;

                    event.preventDefault();
                    this.dom[target].click();
                }
            }

            new PreferenceRank();
        </script>
    </body>
</html>
