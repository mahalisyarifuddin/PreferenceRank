<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--page-background: #f9f9ff;
				--container-background: #fff;
				--text-color: #414754;
				--border: #c1c6d7;
				--button-hover: #d7d9e5
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--page-background:#10131b;
					--container-background: #181c23;
					--text-color: #c1c6d7;
					--border: #414754;
					--button-hover: #10131b
				}
			}

			:root.dark {
				--page-background: #10131b;
				--container-background: #181c23;
				--text-color: #c1c6d7;
				--border: #414754;
				--button-hover: #10131b
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--page-background);
				color: var(--text-color);
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
				font-family: sans-serif
			}

			.container {
				background: var(--container-background);
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0,0,0,.1);
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative
			}

			.container:has(#inputSection:not(.hidden)) {
				padding-top: 3rem
			}

			.hidden {
				display: none!important
			}

			h1,h2 {
				margin: .5rem 0;
				text-align: left
			}

			.form-field {
				margin-bottom: 1rem
			}

			label {
				display: block;
				font-weight: 700;
				margin-bottom: .5rem
			}

			input,select,textarea,button {
				background: var(--container-background);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text-color);
				font-size: 1rem;
				padding: .5rem;
				width: 100%
			}

			textarea {
				min-height: 80px;
				resize: vertical
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			.button-primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.button-primary:hover {
				background: var(--primary-hover)
			}

			.button-secondary {
				background: var(--container-background);
				color: var(--text-color)
			}

			.button-secondary:hover {
				background: var(--button-hover)
			}

			#battle,#restartButtons,#tieButtons {
				display: flex;
				gap: 1rem;
				margin-top: 1rem
			}

			#battle button,#tieButtons button,#restartButtons button {
				flex: 1
			}

			#battle button,#tieButtons button {
				font-size: 1.2rem;
				min-height: 100px
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center
			}

			#keyboardTip {
				background: var(--page-background);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: .9;
				padding: 8px;
				text-align: center
			}

			#keyboardTip kbd {
				background: var(--container-background);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0,0,0,.2);
				display: inline-block;
				font-family: monospace;
				font-size: .9em;
				margin: 0 3px;
				padding: 2px 5px
			}

			#keyboardTipToggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: .85rem;
				margin: 10px auto 0;
				padding: 0;
				text-decoration: underline;
				width: auto
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px
			}

			.selectors select {
				font-size: .9rem;
				padding: 5px;
				width: auto
			}

			.checkbox {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: .75rem 0
			}

			.checkbox input {
				width: auto
			}

			.checkbox label {
				margin: 0
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%
			}

			#results th,#results td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left
			}

			#results th {
				background: var(--primary);
				color: #fff
			}

			#undoButton {
				margin-top: 1rem;
				width: auto
			}

			#undoButton:disabled {
				background: var(--button-hover);
				cursor: not-allowed
			}

			.selected {
				background: var(--primary)!important;
				color: #fff!important
			}

			#notification {
				background: var(--primary);
				color: #fff;
				padding: 1rem;
				border-radius: 4px;
				margin-bottom: 1rem;
				text-align: center
			}

			@media(max-width: 768px) {
				.container {
					padding:1.5rem
				}

				.container:has(#inputSection:not(.hidden)) {
					padding-top: calc(1.5rem + 1rem)
				}

				.selectors {
					gap: 4px;
					right: .5rem;
					top: .5rem
				}

				.selectors select {
					font-size: .8rem;
					padding: 4px
				}

				#battle,#tieButtons,#restartButtons {
					flex-direction: column
				}

				#battle button,#tieButtons button {
					width: 100%
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="notification" class="hidden"></div>
			<div id="inputSection">
				<h1 id="title" data-translate="title"></h1>
				<div class="selectors">
					<select id="langSelect">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="themeSelect">
						<option value="auto" id="autoTheme" data-translate="autoTheme"></option>
						<option value="light" id="lightTheme" data-translate="lightTheme"></option>
						<option value="dark" id="darkTheme" data-translate="darkTheme"></option>
					</select>
				</div>
				<div class="form-group">
					<label for="itemInput" id="itemInputLabel" data-translate="itemInputLabel"></label>
					<textarea id="itemInput" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="allowTies"/>
					<label for="allowTies" id="allowTiesLabel" data-translate="allowTiesLabel"></label>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="quickRank"/>
					<label for="quickRank" id="quickRankLabel" data-translate="quickRankLabel"></label>
				</div>
				<button id="startButton" class="button-primary" data-translate="startButton"></button>
			</div>
			<div id="battleSection" class="hidden">
				<button id="undoButton" class="button-secondary" data-translate="undoButton" disabled></button>
				<div id="battle">
					<button id="leftItem" class="button-secondary"></button>
					<button id="rightItem" class="button-secondary"></button>
				</div>
				<div id="tieButtons" class="hidden">
					<button id="tieButton" class="button-secondary" data-translate="tieButton"></button>
				</div>
				<div id="progress"></div>
				<button id="keyboardTipToggle"></button>
				<div id="keyboardTip" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartButtons" class="hidden">
				<button id="restartBattleButton" class="button-primary" data-translate="restartBattleButton"></button>
				<button id="restartNewButton" class="button-primary" data-translate="restartNewButton"></button>
			</div>
		</div>
		<script>
			const getElement = elementId=>document.getElementById(elementId);

			const translations = {
				en: {
					title: "PreferenceRank",
					autoTheme: "Auto Theme",
					lightTheme: "Light",
					darkTheme: "Dark",
					itemInputLabel: "Enter items, one per line:",
					allowTiesLabel: "Allow Ties",
					quickRankLabel: "Use Quick Rank (fewer comparisons)",
					alert: "Please enter at least two items.",
					duplicateAlert: "{count} duplicate item(s) were found and have been removed.",
					startButton: "Start Ranking",
					tieButton: "It's a Tie",
					undoButton: "Undo",
					progress: "Progress",
					keyboardTipToggle: "Show keyboard shortcuts",
					keyboardTipHide: "Hide keyboard shortcuts",
					keyboardTipWithTies: "Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> or <kbd>↓</kbd> It's a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice",
					keyboardTipNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					results: "Results",
					rank: "Rank",
					item: "Item",
					score: "Score",
					restartBattleButton: "Restart Battle",
					restartNewButton: "Start with New Items"
				},
				id: {
					title: "PreferenceRank",
					autoTheme: "Tema Otomatis",
					lightTheme: "Terang",
					darkTheme: "Gelap",
					itemInputLabel: "Masukkan pilihan, satu per baris:",
					allowTiesLabel: "Izinkan Seri",
					quickRankLabel: "Gunakan Peringkat Cepat (lebih sedikit perbandingan)",
					alert: "Harap masukkan setidaknya dua pilihan.",
					duplicateAlert: "{count} item duplikat ditemukan dan telah dihapus.",
					startButton: "Mulai Peringkat",
					tieButton: "Seri",
					undoButton: "Urungkan",
					progress: "Kemajuan",
					keyboardTipToggle: "Tampilkan pintasan papan ketik",
					keyboardTipHide: "Sembunyikan pintasan papan ketik",
					keyboardTipWithTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> atau <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					keyboardTipNoTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					results: "Hasil",
					rank: "Peringkat",
					item: "Nama",
					score: "Skor",
					restartBattleButton: "Mulai Ulang Pertarungan",
					restartNewButton: "Mulai dengan Pilihan Baru"
				}
			};

			class PairProvider {
				constructor(itemCount) {
					this.itemCount = itemCount;
				}

				static shuffleArray(array) {
					for (let index = array.length - 1; index > 0; index--) {
						const randomIndex = Math.floor(Math.random() * (index + 1));
						[array[index],array[randomIndex]] = [array[randomIndex], array[index]];
					}
				}

				markAsCompared() {}
				unmarkAsCompared() {}
			}

			class FullPairProvider extends PairProvider {
				constructor(itemCount) {
					super(itemCount);
					this.pairs = [];

					for (let firstIndex = 0; firstIndex < itemCount - 1; firstIndex++) {
						for (let secondIndex = firstIndex + 1; secondIndex < itemCount; secondIndex++) {
							this.pairs.push([firstIndex, secondIndex]);
						}
					}

					PairProvider.shuffleArray(this.pairs);
				}

				getNextPair(state) {
					return this.pairs[state.progress];
				}

				getTotalPairs() {
					return this.pairs.length;
				}
			}

			class QuickPairProvider extends PairProvider {
				constructor(itemCount) {
					super(itemCount);
					this.comparedPairs = new Set();
				}

				getNextPair(state) {
					const sortedIndices = Array.from({
						length: this.itemCount
					}, (_,index)=>index).sort((firstItem,secondItem)=>state.scores[secondItem] - state.scores[firstItem]);

					for (let position = 0; position < this.itemCount - 1; position++) {
						const firstIndex = sortedIndices[position];
						const secondIndex = sortedIndices[position + 1];
						const pair = [Math.min(firstIndex, secondIndex), Math.max(firstIndex, secondIndex)];
						const pairKey = `${pair[0]}-${pair[1]}`;

						if (!this.comparedPairs.has(pairKey))
							return pair;
					}

					return null;
				}

				markAsCompared(pair) {
					this.comparedPairs.add(`${pair[0]}-${pair[1]}`);
				}

				unmarkAsCompared(pair) {
					this.comparedPairs.delete(`${pair[0]}-${pair[1]}`);
				}
			}

			class PreferenceRank {
				constructor() {
					this.state = this.createInitialState();
					this.initializeElements();
					this.elements.langSelect.value = this.state.lang;
					this.bindEventListeners();
					this.applyTheme();
					this.updateLanguage();
				}

				createInitialState(preserve={}) {
					return {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: false,
						progress: 0,
						totalPairs: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						isChoosing: false,
						lang: preserve.lang || (navigator.language?.startsWith('id') ? 'id' : 'en'),
						theme: preserve.theme || 'auto'
					};
				}

				translate(key, replacements={}) {
					let text = translations[this.state.lang][key] || key;
					Object.entries(replacements).forEach(([placeholder,value])=>{
						text = text.replace(`{${placeholder}}`, value);
					}
					);
					return text;
				}

				initializeElements() {
					this.elements = Object.fromEntries(Array.from(document.querySelectorAll('[id]')).map(element=>[element.id, element]));
				}

				bindEventListeners() {
					const listeners = {
						langSelect: {event: 'change', handler: ()=>this.updateLanguage()},
						themeSelect: {event: 'change', handler: event=>this.handleThemeChange(event.target.value)},
						allowTies: {event: 'change', handler: event=>this.handleAllowTiesChange(event.target.checked)},
						startButton: {event: 'click', handler: ()=>this.startRanking()},
						leftItem: {event: 'click', handler: ()=>this.handleChoice('left')},
						rightItem: {event: 'click', handler: ()=>this.handleChoice('right')},
						tieButton: {event: 'click', handler: ()=>this.handleChoice('tie')},
						restartBattleButton: {event: 'click', handler: ()=>this.restartBattle()},
						restartNewButton: {event: 'click', handler: ()=>this.restartWithNewItems()},
						undoButton: {event: 'click', handler: ()=>this.undoLastChoice()},
						keyboardTipToggle: {event: 'click', handler: ()=>this.toggleKeyboardTip()},
						document: {event: 'keydown', handler: event=>this.handleKeyboardInput(event)}
					};

					Object.entries(listeners).forEach(([elementId, {event, handler}])=>{
						const element = elementId === 'document' ? document : this.elements[elementId];
						element.addEventListener(event, handler);
					});
				}

				handleThemeChange(theme) {
					this.state.theme = theme;
					this.applyTheme();
				}

				applyTheme() {
					document.documentElement.classList.remove('light', 'dark');
					if (this.state.theme !== 'auto') {
						document.documentElement.classList.add(this.state.theme);
					}
				}

				handleAllowTiesChange(checked) {
					this.state.allowTies = checked;
					if (!this.elements.battleSection.classList.contains('hidden')) {
						this.elements.tieButtons.classList.toggle('hidden', !checked);
						this.updateKeyboardTipContent();
					}
				}

				updateLanguage() {
					this.state.lang = this.elements.langSelect.value;

					document.querySelectorAll('[data-translate]').forEach(element=>{
						element.textContent = this.translate(element.dataset.translate);
					});

					this.updateKeyboardTipContent();
					this.updateKeyboardTipToggleText();
					this.updateProgressDisplay();

					if (!this.elements.results.classList.contains('hidden')) {
						this.displayResults();
					}
				}

				updateKeyboardTipContent() {
					const tooltipKey = this.state.allowTies ? 'keyboardTipWithTies' : 'keyboardTipNoTies';
					this.elements.keyboardTip.innerHTML = this.translate(tooltipKey);
				}

				updateKeyboardTipToggleText() {
					const isHidden = this.elements.keyboardTip.classList.contains('hidden');
					const toggleKey = isHidden ? 'keyboardTipToggle' : 'keyboardTipHide';
					this.elements.keyboardTipToggle.textContent = this.translate(toggleKey);
				}

				showNotification(message, duration=3000) {
					this.elements.notification.textContent = message;
					this.elements.notification.classList.remove('hidden');
					setTimeout(()=>{
						this.elements.notification.classList.add('hidden');
					}
					, duration);
				}

				parseInputItems() {
					const rawItems = this.elements.itemInput.value.split('\n').map(line=>line.trim()).filter(Boolean);

					const uniqueItems = [...new Set(rawItems)];
					const duplicateCount = rawItems.length - uniqueItems.length;

					if (duplicateCount > 0) {
						this.showNotification(this.translate('duplicateAlert', {
							count: duplicateCount
						}));
					}

					return uniqueItems;
				}

				startRanking() {
					const items = this.parseInputItems();

					if (items.length < 2) {
						return this.showNotification(this.translate('alert'));
					}

					this.state.items = items;
					this.state.allowTies = this.elements.allowTies.checked;
					this.resetBattleState();
					this.elements.tieButtons.classList.toggle('hidden', !this.state.allowTies);
					this.toggleKeyboardTip(true);
					this.updateKeyboardTipContent();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				resetBattleState() {
					const itemCount = this.state.items.length;

					this.state.scores = Array(itemCount).fill(1000);
					this.state.progress = 0;
					this.state.history = [];
					this.elements.undoButton.disabled = true;

					const isQuickRank = this.elements.quickRank.checked;
					this.state.pairProvider = isQuickRank ? new QuickPairProvider(itemCount) : new FullPairProvider(itemCount);

					this.state.totalPairs = isQuickRank ? 0 : this.state.pairProvider.getTotalPairs();
				}

				calculateNewScores(winner) {
					const {currentPair, isSwapped, scores} = this.state;
					const isFirstItemWinner = (winner === 'left' && !isSwapped) || (winner === 'right' && isSwapped);
					const result = winner === 'tie' ? 0.5 : (isFirstItemWinner ? 1 : 0);
					const [firstIndex,secondIndex] = currentPair;
					const [firstScore,secondScore] = [scores[firstIndex], scores[secondIndex]];
					const expectedFirstScore = 1 / (1 + 10 ** ((secondScore - firstScore) / 400));
					const adjustmentFactor = 32;

					scores[firstIndex] += adjustmentFactor * (result - expectedFirstScore);
					scores[secondIndex] += adjustmentFactor * (expectedFirstScore - result);
				}

				handleChoice(winner) {
					if (this.state.isChoosing)
						return;

					this.state.isChoosing = true;
					this.state.history.push({
						pair: this.state.currentPair,
						scores: [...this.state.scores],
						progressBefore: this.state.progress
					});

					this.state.pairProvider.markAsCompared(this.state.currentPair);
					this.calculateNewScores(winner);
					this.state.progress++;
					this.elements.undoButton.disabled = false;
					this.updateProgressDisplay();
					this.animateChoice(winner);
				}

				animateChoice(winner) {
					this.clearButtonSelections();

					const targetButton = winner === 'tie' ? this.elements.tieButton : this.elements[`${winner}Item`];

					targetButton.classList.add('selected');

					setTimeout(()=>{
						this.state.isChoosing = false;
						this.showNextBattle();
					}
					, 300);
				}

				showNextBattle() {
					this.clearButtonSelections();

					const nextPair = this.state.pairProvider.getNextPair(this.state);
					const isQuickRank = this.elements.quickRank.checked;
					const isComplete = !nextPair || (!isQuickRank && this.state.progress >= this.state.totalPairs);

					if (isComplete)
						return this.displayResults();

					this.state.currentPair = nextPair;
					let[firstIndex,secondIndex] = nextPair;

					this.state.isSwapped = Math.random() < 0.5;
					if (this.state.isSwapped) {
						[firstIndex,secondIndex] = [secondIndex, firstIndex];
					}

					this.elements.leftItem.textContent = this.state.items[firstIndex];
					this.elements.rightItem.textContent = this.state.items[secondIndex];
					this.updateProgressDisplay();
				}

				updateProgressDisplay() {
					const isQuickRank = this.elements.quickRank.checked;
					const progressLabel = this.translate('progress');
					const text = isQuickRank ? `${progressLabel}: ${this.state.progress}` : `${progressLabel}: ${this.state.progress}/${this.state.totalPairs}`;

					this.elements.progress.textContent = text;
				}

				clearButtonSelections() {
					['leftItem', 'rightItem', 'tieButton'].forEach(elementId=>{
						this.elements[elementId].classList.remove('selected');
					}
					);
				}

				displayResults() {
					const sortedResults = this.state.items.map((item,index)=>({
						item,
						score: this.state.scores[index]
					})).sort((firstItem,secondItem)=>secondItem.score - firstItem.score);

					const tableRows = sortedResults.map(({item, score},index)=>`
							<tr>
								<td>${index + 1}</td>
								<td>${item}</td>
								<td>${Math.round(score)}</td>
							</tr>
						`).join('');

					this.elements.results.innerHTML = `
						<h2>${this.translate('results')}</h2>
						<table>
							<thead>
								<tr>
									<th style="width:20%">${this.translate('rank')}</th>
									<th style="width:60%">${this.translate('item')}</th>
									<th style="width:20%">${this.translate('score')}</th>
								</tr>
							</thead>
							<tbody>${tableRows}</tbody>
						</table>
					`;

					this.showSection('results');
				}

				showSection(sectionName) {
					const sections = ['inputSection', 'battleSection', 'results'];
					sections.forEach(section=>{
						this.elements[section].classList.toggle('hidden', section !== sectionName);
					}
					);

					this.elements.restartButtons.classList.toggle('hidden', sectionName !== 'results');
					this.state.keyboardEnabled = sectionName === 'battleSection';
				}

				undoLastChoice() {
					if (this.state.isChoosing || !this.state.history.length)
						return;

					const lastState = this.state.history.pop();
					this.state.scores = lastState.scores;
					this.state.progress = lastState.progressBefore;
					this.state.pairProvider.unmarkAsCompared(lastState.pair);
					this.showNextBattle();
					this.elements.undoButton.disabled = !this.state.history.length;
				}

				restartBattle() {
					this.resetBattleState();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				restartWithNewItems() {
					this.state = this.createInitialState({
						lang: this.state.lang,
						theme: this.state.theme
					});

					this.elements.langSelect.value = this.state.lang;
					this.elements.itemInput.value = '';
					this.elements.allowTies.checked = false;
					this.elements.quickRank.checked = false;
					this.showSection('inputSection');
					this.updateLanguage();
				}

				toggleKeyboardTip(forceHide) {
					const isHidden = this.elements.keyboardTip.classList.toggle('hidden', forceHide);
					this.updateKeyboardTipToggleText();
				}

				handleKeyboardInput(event) {
					const isInputFocused = ['SELECT', 'INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);

					if (!this.state.keyboardEnabled || isInputFocused)
						return;

					const keyActions = {
						ArrowLeft: ()=>this.elements.leftItem.click(),
						ArrowRight: ()=>this.elements.rightItem.click(),
						ArrowUp: ()=>this.state.allowTies && this.elements.tieButton.click(),
						ArrowDown: ()=>this.state.allowTies && this.elements.tieButton.click(),
						z: ()=>(event.ctrlKey || event.metaKey) && this.elements.undoButton.click()
					};

					const action = keyActions[event.key];
					if (action) {
						event.preventDefault();
						action();
					}
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
