<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--page-background: #f9f9ff;
				--container-background: #fff;
				--text-color: #414754;
				--border: #c1c6d7;
				--button-hover: #d7d9e5;
			}

			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--page-background: #10131b;
					--container-background: #181c23;
					--text-color: #c1c6d7;
					--border: #414754;
					--button-hover: #10131b;
				}
			}

			:root.dark {
				--page-background: #10131b;
				--container-background: #181c23;
				--text-color: #c1c6d7;
				--border: #414754;
				--button-hover: #10131b;
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			body {
				background: var(--page-background);
				color: var(--text-color);
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
				font-family: sans-serif;
			}

			.container {
				background: var(--container-background);
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0,0,0,0.1);
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative;
			}

			.hidden {
				display: none !important;
			}

			h1, h2 {
				margin: 0.5rem 0;
			}

			label {
				display: block;
				font-weight: 700;
				margin-bottom: 0.5rem;
			}

			input, select, textarea, button {
				background: var(--container-background);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text-color);
				font-size: 1rem;
				padding: 0.5rem;
				width: 100%;
			}

			textarea {
				min-height: 80px;
				resize: vertical;
			}

			button {
				cursor: pointer;
				transition: background 0.2s;
			}

			.button-primary {
				background: var(--primary);
				border: none;
				color: #fff;
			}

			.button-primary:hover {
				background: var(--primary-hover);
			}

			.button-secondary:hover {
				background: var(--button-hover);
			}

			#battle, #restartButtons, #tieButtons {
				display: flex;
				gap: 1rem;
				margin-top: 1rem;
			}

			#battle button, #tieButtons button, #restartButtons button {
				flex: 1;
			}

			#battle button, #tieButtons button {
				font-size: 1.2rem;
				min-height: 100px;
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center;
			}

			#keyboardTip {
				background: var(--page-background);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: 0.85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: 0.9;
				padding: 8px;
				text-align: center;
			}

			#keyboardTip kbd {
				background: var(--container-background);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0,0,0,0.2);
				display: inline-block;
				font-family: monospace;
				font-size: 0.9em;
				margin: 0 3px;
				padding: 2px 5px;
			}

			#keyboardTipToggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: 0.85rem;
				margin: 10px auto 0;
				text-decoration: underline;
				width: auto;
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px;
			}

			.selectors select {
				font-size: 0.9rem;
				padding: 5px;
				width: auto;
			}

			.checkbox {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: 0.75rem 0;
			}

			.checkbox input {
				width: auto;
			}

			.checkbox label {
				margin: 0;
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%;
			}

			#results th, #results td {
				border: 1px solid var(--border);
				padding: 0.5rem;
				text-align: left;
			}

			#results th {
				background: var(--primary);
				color: #fff;
			}

			#undoButton {
				width: auto;
			}

			#undoButton:disabled {
				background: var(--button-hover);
				cursor: not-allowed;
			}

			.selected {
				background: var(--primary) !important;
				color: #fff !important;
			}

			@media (max-width: 768px) {
				body {
					padding: 0.75rem;
				}

				.container {
					padding: 1.5rem;
				}

				.selectors {
					gap: 4px;
					right: 0.5rem;
					top: 0.5rem;
				}

				.selectors select {
					font-size: 0.8rem;
					padding: 4px;
				}

				#battle, #tieButtons, #restartButtons {
					flex-direction: column;
				}

				#battle button, #tieButtons button {
					width: 100%;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="inputSection">
				<h1 id="title"></h1>
				<div class="selectors">
					<select id="langSelect">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="themeSelect">
						<option value="auto" id="autoTheme"></option>
						<option value="light" id="lightTheme"></option>
						<option value="dark" id="darkTheme"></option>
					</select>
				</div>
				<div class="form-group">
					<label for="itemInput" id="itemInputLabel"></label>
					<textarea id="itemInput" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="allowTies"/>
					<label for="allowTies" id="allowTiesLabel"></label>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="quickRank"/>
					<label for="quickRank" id="quickRankLabel"></label>
				</div>
				<button id="startButton" class="button-primary"></button>
			</div>
			<div id="battleSection" class="hidden">
				<button id="undoButton" class="button-secondary" disabled></button>
				<div id="battle">
					<button id="leftItem" class="button-secondary"></button>
					<button id="rightItem" class="button-secondary"></button>
				</div>
				<div id="tieButtons" class="hidden">
					<button id="tieButton" class="button-secondary"></button>
				</div>
				<div id="progress"></div>
				<button id="keyboardTipToggle"></button>
				<div id="keyboardTip" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartButtons" class="hidden">
				<button id="restartBattleButton" class="button-primary"></button>
				<button id="restartNewButton" class="button-primary"></button>
			</div>
		</div>
		<script>
			const translations = {
				en: {
					title: 'PreferenceRank',
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
					itemInputLabel: 'Enter items, one per line:',
					allowTiesLabel: 'Allow Ties',
					quickRankLabel: 'Use Quick Rank (fewer comparisons)',
					alert: 'Please enter at least two items.',
					duplicateAlert: '{count} duplicate item(s) were found and have been removed.',
					startButton: 'Start Ranking',
					tieButton: "It's a Tie",
					undoButton: 'Undo',
					progress: 'Progress',
					keyboardTipToggle: 'Show keyboard shortcuts',
					keyboardTipHide: 'Hide keyboard shortcuts',
					keyboardTipWithTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> / <kbd>↓</kbd> It\'s a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					keyboardTipNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					results: 'Results',
					rank: 'Rank',
					item: 'Item',
					score: 'Score',
					restartBattleButton: 'Restart Battle',
					restartNewButton: 'Start with New Items'
				},
				id: {
					title: 'PreferenceRank',
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
					itemInputLabel: 'Masukkan pilihan, satu per baris:',
					allowTiesLabel: 'Izinkan Seri',
					quickRankLabel: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
					alert: 'Harap masukkan setidaknya dua pilihan.',
					duplicateAlert: '{count} item duplikat ditemukan dan telah dihapus.',
					startButton: 'Mulai Peringkat',
					tieButton: 'Seri',
					undoButton: 'Urungkan',
					progress: 'Kemajuan',
					keyboardTipToggle: 'Tampilkan pintasan papan ketik',
					keyboardTipHide: 'Sembunyikan pintasan papan ketik',
					keyboardTipWithTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> / <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					keyboardTipNoTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					results: 'Hasil',
					rank: 'Peringkat',
					item: 'Nama',
					score: 'Skor',
					restartBattleButton: 'Mulai Ulang Pertarungan',
					restartNewButton: 'Mulai dengan Pilihan Baru'
				}
			};

			function escapeHTML(str) {
				const p = document.createElement('p');
				p.appendChild(document.createTextNode(str));
				return p.innerHTML;
			}

			class PairProvider {
				constructor(itemCount) {
					this.itemCount = itemCount;
					this.comparedPairKeys = new Set();
				}
				toKey([a,b]) {
					return `${Math.min(a, b)}-${Math.max(a, b)}`;
				}
				markCompared(pair) {
					this.comparedPairKeys.add(this.toKey(pair));
				}
				unmarkCompared(pair) {
					this.comparedPairKeys.delete(this.toKey(pair));
				}
				hasBeenCompared(pair) {
					return this.comparedPairKeys.has(this.toKey(pair));
				}
			}

			class FullPairProvider extends PairProvider {
				constructor(itemCount) {
					super(itemCount);
					this.pairs = this.generateAllPairs();
					this.shuffle(this.pairs);
				}
				generateAllPairs() {
					const pairs = [];
					for (let i = 0; i < this.itemCount - 1; i++) {
						for (let j = i + 1; j < this.itemCount; j++) {
							pairs.push([i, j]);
						}
					}
					return pairs;
				}
				shuffle(array) {
					for (let i = array.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[array[i],array[j]] = [array[j], array[i]];
					}
				}
				getNextPair(state) {
					return this.pairs[state.progress];
				}
				getTotalPairs() {
					return this.pairs.length;
				}
			}

			class QuickPairProvider extends PairProvider {
				getNextPair(state) {
					const sortedIndices = Array.from({
						length: this.itemCount
					}, (_,i)=>i).sort((a,b)=>state.scores[b] - state.scores[a]);
					for (let i = 0; i < this.itemCount - 1; i++) {
						const pair = [sortedIndices[i], sortedIndices[i + 1]];
						if (!this.hasBeenCompared(pair))
							return pair;
					}
					return null;
				}
			}

			class PreferenceRank {
				constructor() {
					this.elements = Object.fromEntries(Array.from(document.querySelectorAll('[id]')).map(element=>[element.id, element]));
					this.state = this.createInitialState();
					this.bindEventListeners();
					this.applyTheme();
					this.updateLanguage(this.state.language);
				}

				createInitialState(preserve={}) {
					return {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: false,
						progress: 0,
						totalPairs: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						isChoosing: false,
						language: preserve.language || (navigator.language?.startsWith('id') ? 'id' : 'en'),
						theme: preserve.theme || 'auto',
						pairProvider: null,
						pairSwapStates: new Map()
					};
				}

				translate(key, replacements={}) {
					let text = translations[this.state.language][key] || key;
					for (const [placeholder,value] of Object.entries(replacements)) {
						text = text.replace(`{${placeholder}}`, value);
					}
					return text;
				}

				bindEventListeners() {
					const {startButton, leftItem, rightItem, tieButton, restartBattleButton, restartNewButton, undoButton, keyboardTipToggle, langSelect, themeSelect, allowTies} = this.elements;

					startButton.addEventListener('click', ()=>this.startRanking());
					leftItem.addEventListener('click', ()=>this.handleChoice('left'));
					rightItem.addEventListener('click', ()=>this.handleChoice('right'));
					tieButton.addEventListener('click', ()=>this.handleChoice('tie'));
					restartBattleButton.addEventListener('click', ()=>this.restartBattle());
					restartNewButton.addEventListener('click', ()=>this.restartWithNewItems());
					undoButton.addEventListener('click', ()=>this.undoLastChoice());
					keyboardTipToggle.addEventListener('click', ()=>this.toggleKeyboardTip());

					langSelect.addEventListener('change', ()=>this.updateLanguage(langSelect.value));
					themeSelect.addEventListener('change', event=>this.setTheme(event.target.value));
					allowTies.addEventListener('change', event=>this.handleAllowTiesChange(event.target.checked));

					document.addEventListener('keydown', event=>this.handleKeyboardInput(event));
				}

				setTheme(theme) {
					this.state.theme = theme || this.state.theme;
					this.applyTheme();
				}

				applyTheme() {
					const html = document.documentElement;
					html.classList.remove('light', 'dark');
					this.state.theme !== 'auto' && html.classList.add(this.state.theme);
					this.elements.themeSelect.value = this.state.theme;
				}

				handleAllowTiesChange(checked) {
					this.state.allowTies = checked;
					const battleHidden = this.elements.battleSection.classList.contains('hidden');
					!battleHidden && this.elements.tieButtons.classList.toggle('hidden', !checked);
					this.updateKeyboardTip();
				}

				updateLanguage(language) {
					this.state.language = language || this.elements.langSelect.value;
					this.elements.langSelect.value = this.state.language;

					const textElementKeys = ['title', 'autoTheme', 'lightTheme', 'darkTheme', 'itemInputLabel', 'allowTiesLabel', 'quickRankLabel', 'startButton', 'tieButton', 'undoButton', 'restartBattleButton', 'restartNewButton'];

					textElementKeys.forEach(key=>{
						this.elements[key].textContent = this.translate(key);
					}
					);

					this.updateKeyboardTip();
					this.updateProgressDisplay();
					const resultsHidden = this.elements.results.classList.contains('hidden');
					!resultsHidden && this.displayResults();
				}

				updateKeyboardTip() {
					const isHidden = this.elements.keyboardTip.classList.contains('hidden');
					this.elements.keyboardTipToggle.textContent = this.translate(isHidden ? 'keyboardTipToggle' : 'keyboardTipHide');
					this.elements.keyboardTip.innerHTML = this.translate(this.state.allowTies ? 'keyboardTipWithTies' : 'keyboardTipNoTies');
				}

				resetBattleState() {
					const itemCount = this.state.items.length;
					this.state.scores = Array(itemCount).fill(1000);
					this.state.progress = 0;
					this.state.history = [];
					this.state.pairSwapStates = new Map();
					this.elements.undoButton.disabled = true;

					const isQuickRank = this.elements.quickRank.checked;
					this.state.pairProvider = isQuickRank ? new QuickPairProvider(itemCount) : new FullPairProvider(itemCount);
					this.state.totalPairs = isQuickRank ? 0 : this.state.pairProvider.getTotalPairs();
				}

				startRanking() {
					const rawItems = this.elements.itemInput.value.split('\n').map(line=>line.trim()).filter(Boolean);
					const uniqueItems = [...new Set(rawItems)];
					const duplicateCount = rawItems.length - uniqueItems.length;

					duplicateCount > 0 && alert(this.translate('duplicateAlert', {
						count: duplicateCount
					}));
					if (uniqueItems.length < 2) {
						alert(this.translate('alert'));
						return;
					}

					this.state.items = uniqueItems;
					this.state.allowTies = this.elements.allowTies.checked;

					this.resetBattleState();
					this.elements.tieButtons.classList.toggle('hidden', !this.state.allowTies);
					this.toggleKeyboardTip(true);
					this.updateKeyboardTip();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				calculateNewScores(winner) {
					const {currentPair, isSwapped, scores} = this.state;
					const isFirstItemWinner = (winner === 'left' && !isSwapped) || (winner === 'right' && isSwapped);
					const result = winner === 'tie' ? 0.5 : isFirstItemWinner ? 1 : 0;

					const [firstIndex,secondIndex] = currentPair;
					const firstScore = scores[firstIndex];
					const secondScore = scores[secondIndex];

					const expectedFirstScore = 1 / (1 + 10 ** ((secondScore - firstScore) / 400));
					const adjustment = 32;

					scores[firstIndex] += adjustment * (result - expectedFirstScore);
					scores[secondIndex] += adjustment * (expectedFirstScore - result);
				}

				handleChoice(winner) {
					if (this.state.isChoosing)
						return;

					this.state.isChoosing = true;
					this.state.history.push({
						pair: this.state.currentPair,
						scores: [...this.state.scores],
						progressBefore: this.state.progress,
						isSwapped: this.state.isSwapped
					});

					this.state.pairProvider.markCompared(this.state.currentPair);
					this.calculateNewScores(winner);
					this.state.progress++;
					this.elements.undoButton.disabled = false;
					this.updateProgressDisplay();

					this.clearButtonSelections();
					const targetButton = winner === 'tie' ? this.elements.tieButton : this.elements[`${winner}Item`];
					targetButton.classList.add('selected');

					setTimeout(()=>{
						this.state.isChoosing = false;
						this.showNextBattle();
					}
					, 300);
				}

				displayCurrentBattle() {
					this.clearButtonSelections();

					let[firstIndex,secondIndex] = this.state.currentPair;
					if (this.state.isSwapped) {
						[firstIndex,secondIndex] = [secondIndex, firstIndex];
					}

					this.elements.leftItem.textContent = this.state.items[firstIndex];
					this.elements.rightItem.textContent = this.state.items[secondIndex];
					this.updateProgressDisplay();
				}

				showNextBattle() {
					this.clearButtonSelections();
					const nextPair = this.state.pairProvider.getNextPair(this.state);
					const isQuickRank = this.elements.quickRank.checked;

					if (!nextPair || (!isQuickRank && this.state.progress >= this.state.totalPairs)) {
						this.displayResults();
						return;
					}

					this.state.currentPair = nextPair;

					const pairKey = this.state.pairProvider.toKey(nextPair);
					this.state.pairSwapStates.has(pairKey) || this.state.pairSwapStates.set(pairKey, Math.random() < 0.5);
					this.state.isSwapped = this.state.pairSwapStates.get(pairKey);

					this.displayCurrentBattle();
				}

				updateProgressDisplay() {
					const label = this.translate('progress');
					this.elements.progress.textContent = this.elements.quickRank.checked ? `${label}: ${this.state.progress}` : `${label}: ${this.state.progress}/${this.state.totalPairs}`;
				}

				clearButtonSelections() {
					['leftItem', 'rightItem', 'tieButton'].forEach(id=>this.elements[id].classList.remove('selected'));
				}

				displayResults() {
					const sortedResults = this.state.items.map((item,index)=>({
						item,
						score: this.state.scores[index]
					})).sort((a,b)=>b.score - a.score);

					const headers = [{
						key: 'rank',
						width: '20%'
					}, {
						key: 'item',
						width: '60%'
					}, {
						key: 'score',
						width: '20%'
					}].map(({key, width})=>`<th style="width:${width}">${this.translate(key)}</th>`).join('');

					const rows = sortedResults.map(({item, score},index)=>`<tr><td>${index + 1}</td><td>${escapeHTML(item)}</td><td>${Math.round(score)}</td></tr>`).join('');

					this.elements.results.innerHTML = `
					<h2>${this.translate('results')}</h2>
					<table>
						<thead><tr>${headers}</tr></thead>
						<tbody>${rows}</tbody>
					</table>
				`;
					this.showSection('results');
				}

				showSection(sectionId) {
					['inputSection', 'battleSection', 'results'].forEach(id=>{
						this.elements[id].classList.toggle('hidden', id !== sectionId);
					}
					);
					this.elements.restartButtons.classList.toggle('hidden', sectionId !== 'results');
					this.state.keyboardEnabled = sectionId === 'battleSection';
				}

				undoLastChoice() {
					if (this.state.isChoosing || !this.state.history.length)
						return;

					const lastState = this.state.history.pop();
					this.state.scores = lastState.scores;
					this.state.progress = lastState.progressBefore;
					this.state.currentPair = lastState.pair;
					this.state.isSwapped = lastState.isSwapped;
					this.state.pairProvider.unmarkCompared(lastState.pair);

					this.displayCurrentBattle();

					this.elements.undoButton.disabled = !this.state.history.length;
				}

				restartBattle() {
					this.resetBattleState();
					this.showSection('battleSection');
					this.showNextBattle();
				}

				restartWithNewItems() {
					this.state = this.createInitialState({
						language: this.state.language,
						theme: this.state.theme
					});
					this.elements.itemInput.value = '';
					this.elements.allowTies.checked = false;
					this.elements.quickRank.checked = false;
					this.showSection('inputSection');
					this.updateLanguage(this.state.language);
					this.applyTheme();
				}

				toggleKeyboardTip(forceHidden) {
					const tipElement = this.elements.keyboardTip;
					const explicit = typeof forceHidden === 'boolean';
					const shouldHide = explicit ? forceHidden : !tipElement.classList.contains('hidden');
					tipElement.classList.toggle('hidden', shouldHide);
					this.updateKeyboardTip();
				}

				handleKeyboardInput(event) {
					const activeTag = document.activeElement.tagName;
					const blockedTag = ['SELECT', 'INPUT', 'TEXTAREA'].includes(activeTag);
					if (!this.state.keyboardEnabled || blockedTag)
						return;

					const keyMap = {
						ArrowLeft: 'leftItem',
						ArrowRight: 'rightItem',
						ArrowUp: 'tieButton',
						ArrowDown: 'tieButton',
						z: 'undoButton'
					};

					const elementId = keyMap[event.key];
					if (!elementId)
						return;

					const isUndoKey = event.key === 'z';
					const isArrowUpDown = event.key === 'ArrowUp' || event.key === 'ArrowDown';

					if (isUndoKey && !(event.ctrlKey || event.metaKey))
						return;
					if (isArrowUpDown && !this.state.allowTies)
						return;

					event.preventDefault();
					this.elements[elementId].click();
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
