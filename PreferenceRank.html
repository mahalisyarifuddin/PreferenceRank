<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1.0">
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--background: #f9f9ff;
				--surface: #fff;
				--text: #414754;
				--border: #c1c6d7;
				--hover: #d7d9e5
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--background:#10131b;
					--surface: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--hover: #10131b
				}
			}

			:root.dark {
				--background: #10131b;
				--surface: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--hover: #10131b
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem
			}

			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative
			}

			.hidden {
				display: none!important
			}

			h1,h2 {
				margin: .5rem 0
			}

			label {
				display: block;
				font-weight: 700;
				margin-bottom: .5rem
			}

			input,select,textarea,button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%
			}

			textarea {
				min-height: 80px;
				resize: vertical
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			.primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.primary:hover {
				background: var(--primary-hover)
			}

			.secondary:hover {
				background: var(--hover)
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px
			}

			.selectors select {
				font-size: .9rem;
				padding: 5px;
				width: auto
			}

			.checkbox-container {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: .75rem 0
			}

			.checkbox-container input {
				width: auto
			}

			.checkbox-container label {
				margin: 0
			}

			#battle,#tieContainer,#restartContainer {
				display: flex;
				gap: 1rem;
				margin-top: 1rem
			}

			#battle button,#tieContainer button,#restartContainer button {
				flex: 1
			}

			#battle button,#tieContainer button {
				font-size: 1.2rem;
				min-height: 100px
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center
			}

			#shortcutTip {
				background: var(--background);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: .9;
				padding: 8px;
				text-align: center
			}

			#shortcutTip kbd {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0,0,0,.2);
				display: inline-block;
				font-family: monospace;
				font-size: .9em;
				margin: 0 3px;
				padding: 2px 5px
			}

			#cancel {
				background: none;
				border: 1px solid var(--border);
				color: var(--text);
				cursor: pointer;
				display: block;
				font-size: .9rem;
				margin: 1rem auto;
				padding: 5px 15px;
				width: auto
			}

			#cancel:hover {
				background: var(--hover)
			}

			#shortcutToggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: .85rem;
				margin: 10px auto 0;
				text-decoration: underline;
				width: auto
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%
			}

			#results th,#results td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left
			}

			#results th {
				background: var(--primary);
				color: #fff
			}

			.results-header {
				display: flex;
				justify-content: center;
				align-items: center;
				position: relative;
				min-height: 40px;
				margin-bottom: 1rem
			}

			.results-header h2 {
				margin: 0
			}

			.results-header #undo {
				position: absolute;
				left: 0;
				top: 50%;
				transform: translateY(-50%)
			}

			#undo {
				width: auto
			}

			#undo:disabled {
				background: var(--hover);
				cursor: not-allowed
			}

			.selected {
				background: var(--primary)!important;
				color: #fff!important
			}

			@media(max-width: 768px) {
				body {
					padding:.75rem
				}

				.container {
					padding: 1.5rem
				}

				.selectors {
					position: static;
					justify-content: flex-end;
					margin-bottom: .5rem;
					gap: 4px
				}

				.selectors select {
					font-size: .8rem;
					padding: 4px
				}

				#battle,#tieContainer,#restartContainer {
					flex-direction: column
				}

				#battle button,#tieContainer button {
					width: 100%
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="input">
				<div class="selectors">
					<select id="language">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="theme">
						<option value="auto"></option>
						<option value="light"></option>
						<option value="dark"></option>
					</select>
				</div>
				<h1 id="title"></h1>
				<div class="group">
					<label for="items" id="itemsLabel"></label>
					<textarea id="items" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox-container">
					<input type="checkbox" id="allowTies">
					<label for="allowTies" id="allowTiesLabel"></label>
				</div>
				<div class="checkbox-container">
					<input type="checkbox" id="quickRank">
					<label for="quickRank" id="quickRankLabel"></label>
				</div>
				<button id="start" class="primary"></button>
			</div>
			<button id="undo" class="secondary hidden" disabled></button>
			<div id="battleSection" class="hidden">
				<div id="battle">
					<button id="left" class="secondary"></button>
					<button id="right" class="secondary"></button>
				</div>
				<div id="tieContainer" class="hidden">
					<button id="tie" class="secondary"></button>
				</div>
				<div id="progress"></div>
				<button id="cancel"></button>
				<button id="shortcutToggle"></button>
				<div id="shortcutTip" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartContainer" class="hidden">
				<button id="restartBattle" class="primary"></button>
				<button id="restartNew" class="primary"></button>
			</div>
		</div>
		<script>
			const text = {
				en: {
					title: 'PreferenceRank',
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
					itemsLabel: 'Enter items, one per line:',
					allowTiesLabel: 'Allow Ties',
					quickRankLabel: 'Use Quick Rank (fewer comparisons)',
					alert: 'Please enter at least two items.',
					duplicateAlert: '{count} duplicate item(s) were found and have been removed.',
					start: 'Start Ranking',
					cancel: 'Cancel',
					tie: "It's a Tie",
					undo: 'Undo',
					progress: 'Progress',
					shortcutToggle: 'Show keyboard shortcuts',
					shortcutHide: 'Hide keyboard shortcuts',
					shortcutWithTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> / <kbd>↓</kbd> It\'s a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					shortcutNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					resultsTitle: 'Results',
					rank: 'Rank',
					item: 'Item',
					score: 'Score',
					restartBattle: 'Restart Battle',
					restartNew: 'Start with New Items'
				},
				id: {
					title: 'PreferenceRank',
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
					itemsLabel: 'Masukkan pilihan, satu per baris:',
					allowTiesLabel: 'Izinkan Seri',
					quickRankLabel: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
					alert: 'Harap masukkan setidaknya dua pilihan.',
					duplicateAlert: '{count} item duplikat ditemukan dan telah dihapus.',
					start: 'Mulai Peringkat',
					cancel: 'Batal',
					tie: 'Seri',
					undo: 'Urungkan',
					progress: 'Kemajuan',
					shortcutToggle: 'Tampilkan pintasan papan ketik',
					shortcutHide: 'Sembunyikan pintasan papan ketik',
					shortcutWithTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> / <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					shortcutNoTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
					resultsTitle: 'Hasil',
					rank: 'Peringkat',
					item: 'Nama',
					score: 'Skor',
					restartBattle: 'Mulai Ulang Pertarungan',
					restartNew: 'Mulai dengan Pilihan Baru'
				}
			};

			const escape = value=>Object.assign(document.createElement('p'), {
				textContent: value
			}).innerHTML;

			class PairProvider {
				constructor(count) {
					this.count = count;
					this.compared = new Set();
				}
				key([a,b]) {
					return `${Math.min(a, b)}-${Math.max(a, b)}`;
				}
				mark(pair) {
					this.compared.add(this.key(pair));
				}
				unmark(pair) {
					this.compared.delete(this.key(pair));
				}
				has(pair) {
					return this.compared.has(this.key(pair));
				}
				getResults(items, scores) {
					return items.map((item,i)=>({
						item,
						score: scores[i]
					})).sort((a,b)=>b.score - a.score);
				}
				getProgressText(step) {
					return `${step}`;
				}
			}

			class FullPairProvider extends PairProvider {
				constructor(count) {
					super(count);
					this.pairs = [];
					for (let i = 0; i < count - 1; i++)
						for (let j = i + 1; j < count; j++)
							this.pairs.push([i, j]);
					for (let i = this.pairs.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[this.pairs[i],this.pairs[j]] = [this.pairs[j], this.pairs[i]];
					}
				}
				next(state) {
					return this.pairs[state.step];
				}
				total() {
					return this.pairs.length;
				}
				getProgressText(step) {
					return `${step}/${this.total()}`;
				}
			}

			class QuickPairProvider extends PairProvider {
				constructor(count) {
					super(count);
					this.items = Array.from({
						length: count
					}, (_,i)=>i);
					this.stack = [{
						stage: 0,
						items: [...this.items],
						left: null,
						right: null
					}];
					this.historyStack = [];
					this.pendingPair = null;
					this.previousScores = null;
					this.finalResult = null;
					this.refinePass = 0;
					this.refineIndex = 0;
					this.refineSwapped = false;
					this.maxRefinePasses = 3;
				}

				snapshot() {
					return JSON.stringify({
						stack: this.stack,
						pendingPair: this.pendingPair,
						previousScores: this.previousScores,
						compared: Array.from(this.compared),
						finalResult: this.finalResult,
						refinePass: this.refinePass,
						refineIndex: this.refineIndex,
						refineSwapped: this.refineSwapped
					});
				}

				restore(json) {
					const data = JSON.parse(json);
					this.stack = data.stack;
					this.pendingPair = data.pendingPair;
					this.previousScores = data.previousScores;
					this.compared = new Set(data.compared);
					this.finalResult = data.finalResult || null;
					this.refinePass = data.refinePass || 0;
					this.refineIndex = data.refineIndex || 0;
					this.refineSwapped = data.refineSwapped || false;
				}

				unmark(pair) {
					if (this.historyStack.length > 0)
						this.historyStack.pop();
					if (this.historyStack.length > 0)
						this.restore(this.historyStack[this.historyStack.length - 1]);
					super.unmark(pair);
				}

				next(state) {
					if (!this.previousScores)
						this.previousScores = [...state.scores];
					if (this.pendingPair) {
						const [a,b] = this.pendingPair;
						const change = state.scores[a] - this.previousScores[a];
						const expected = 1 / (1 + 10 ** ((this.previousScores[b] - this.previousScores[a]) / 400));
						const result = (change / 32) + expected;
						const winnerId = Math.abs(result - 0.5) < 0.01 ? b : result > 0.75 ? a : b;

						this.stack.length > 0 && this.stack[this.stack.length - 1].mergeResult.push((winnerId === a ? this.stack[this.stack.length - 1].left : this.stack[this.stack.length - 1].right).shift());

						this.finalResult && winnerId === b && ([this.finalResult[this.refineIndex],this.finalResult[this.refineIndex + 1]] = [this.finalResult[this.refineIndex + 1], this.finalResult[this.refineIndex]],
						this.refineSwapped = true);
						this.finalResult && this.refineIndex++;

						this.pendingPair = null;
						this.previousScores = [...state.scores];
					}

					while (this.stack.length > 0) {
						const frame = this.stack[this.stack.length - 1];
						if (frame.stage === 0) {
							if (frame.items.length <= 1) {
								frame.result = frame.items;
								this.popAndPass(frame.result);
								continue;
							}
							const mid = Math.floor(frame.items.length / 2);
							frame.stage = 1;
							frame.leftItems = frame.items.slice(0, mid);
							frame.rightItems = frame.items.slice(mid);
							this.stack.push({
								stage: 0,
								items: frame.leftItems,
								left: null,
								right: null
							});
							continue;
						}
						if (frame.stage === 1) {
							frame.stage = 2;
							this.stack.push({
								stage: 0,
								items: frame.rightItems,
								left: null,
								right: null
							});
							continue;
						}
						if (frame.stage === 2) {
							if (!frame.mergeResult) {
								frame.mergeResult = [];
								frame.left = [...frame.leftResult];
								frame.right = [...frame.rightResult];
							}
							while (frame.left.length > 0 && frame.right.length > 0) {
								const pair = [frame.left[0], frame.right[0]];
								this.historyStack.push(this.snapshot());
								this.pendingPair = pair;
								return pair;
							}
							frame.mergeResult.push(...frame.left, ...frame.right);
							this.popAndPass(frame.mergeResult);
							continue;
						}
					}

					if (this.finalResult) {
						while (true) {
							if (this.refinePass >= this.maxRefinePasses) {
								this.historyStack.push(this.snapshot());
								return null;
							}

							if (this.refineIndex >= this.finalResult.length - 1) {
								if (!this.refineSwapped) {
									this.historyStack.push(this.snapshot());
									return null;
								}
								this.refinePass++;
								this.refineIndex = 0;
								this.refineSwapped = false;
								continue;
							}

							const a = this.finalResult[this.refineIndex];
							const b = this.finalResult[this.refineIndex + 1];
							this.historyStack.push(this.snapshot());
							this.pendingPair = [a, b];
							return [a, b];
						}
					}

					this.historyStack.push(this.snapshot());
					return null;
				}

				popAndPass(result) {
					this.stack.pop();
					const parent = this.stack[this.stack.length - 1];
					this.stack.length > 0 ? (parent.stage === 1 ? parent.leftResult = result : parent.rightResult = result) : this.finalResult = result;
				}

				getResults(items, scores) {
					if (!this.finalResult)
						return super.getResults(items, scores);
					const sortedScores = [...scores].sort((a,b)=>b - a);
					return this.finalResult.map((index,i)=>({
						item: items[index],
						score: sortedScores[i]
					}));
				}
			}

			class PreferenceRank {
				constructor() {
					this.dom = Object.fromEntries([...document.querySelectorAll('[id]')].map(node=>[node.id, node]));
					this.items = [];
					this.scores = [];
					this.pair = null;
					this.swapped = false;
					this.step = 0;
					this.ties = false;
					this.history = [];
					this.keyboard = false;
					this.choosing = false;
					this.language = navigator.language?.startsWith('id') ? 'id' : 'en';
					this.provider = null;
					this.swaps = new Map();
					this.init();
				}

				init() {
					this.bind();
					this.setTheme('auto');
					this.setLanguage(this.language);
					this.undoParent = this.dom.undo.parentNode;
					this.undoSibling = this.dom.battleSection;
				}

				bind() {
					const {dom} = this;
					dom.start.onclick = ()=>this.startRanking();
					dom.cancel.onclick = ()=>this.cancel();
					dom.left.onclick = ()=>this.choose('left');
					dom.right.onclick = ()=>this.choose('right');
					dom.tie.onclick = ()=>this.choose('tie');
					dom.restartBattle.onclick = ()=>this.restart();
					dom.restartNew.onclick = ()=>this.reset();
					dom.undo.onclick = ()=>this.undoChoice();
					dom.shortcutToggle.onclick = ()=>this.toggleShortcuts();
					dom.language.onchange = event=>this.setLanguage(event.target.value);
					dom.theme.onchange = event=>this.setTheme(event.target.value);
					dom.allowTies.onchange = event=>this.setTies(event.target.checked);
					document.onkeydown = event=>this.handleKey(event);
				}

				string(key) {
					return text[this.language][key];
				}

				template(key, values) {
					return Object.entries(values || {}).reduce((result,[k,v])=>result.replace(`{${k}}`, v), this.string(key));
				}

				setTheme(theme) {
					document.documentElement.classList.remove('light', 'dark');
					if (theme !== 'auto')
						document.documentElement.classList.add(theme);
					this.dom.theme.value = theme;
				}

				setLanguage(language) {
					this.language = language;
					this.dom.language.value = language;
					document.documentElement.lang = language;
					const {dom} = this
					  , source = text[language];
					dom.title.textContent = source.title;
					dom.theme.options[0].textContent = source.autoTheme;
					dom.theme.options[1].textContent = source.lightTheme;
					dom.theme.options[2].textContent = source.darkTheme;
					dom.itemsLabel.textContent = source.itemsLabel;
					dom.allowTiesLabel.textContent = source.allowTiesLabel;
					dom.quickRankLabel.textContent = source.quickRankLabel;
					dom.start.textContent = source.start;
					dom.cancel.textContent = source.cancel;
					dom.tie.textContent = source.tie;
					dom.undo.textContent = source.undo;
					dom.restartBattle.textContent = source.restartBattle;
					dom.restartNew.textContent = source.restartNew;
					this.updateShortcuts();
					this.updateProgress();
					if (!dom.results.classList.contains('hidden'))
						this.showResults();
				}

				setTies(enabled) {
					this.ties = enabled;
					if (!this.dom.battleSection.classList.contains('hidden'))
						this.dom.tieContainer.classList.toggle('hidden', !enabled);
					this.updateShortcuts();
				}

				updateShortcuts() {
					const hidden = this.dom.shortcutTip.classList.contains('hidden');
					this.dom.shortcutToggle.textContent = hidden ? this.string('shortcutToggle') : this.string('shortcutHide');
					this.dom.shortcutTip.innerHTML = this.string(this.ties ? 'shortcutWithTies' : 'shortcutNoTies');
				}

				toggleShortcuts(forceHide) {
					const hide = typeof forceHide === 'boolean' ? forceHide : !this.dom.shortcutTip.classList.contains('hidden');
					this.dom.shortcutTip.classList.toggle('hidden', hide);
					this.updateShortcuts();
				}

				initBattle() {
					const count = this.items.length;
					this.scores = Array(count).fill(1000);
					this.step = 0;
					this.history = [];
					this.swaps = new Map();
					this.dom.undo.disabled = true;
					this.provider = this.dom.quickRank.checked ? new QuickPairProvider(count) : new FullPairProvider(count);
				}

				cancel() {
					this.show('input');
				}

				startRanking() {
					const raw = this.dom.items.value.split('\n').map(line=>line.trim()).filter(Boolean);
					const unique = [...new Set(raw)];
					const duplicates = raw.length - unique.length;
					if (duplicates > 0)
						alert(this.template('duplicateAlert', {
							count: duplicates
						}));
					if (unique.length < 2)
						return alert(this.string('alert'));

					this.items = unique;
					this.ties = this.dom.allowTies.checked;
					this.initBattle();
					this.dom.tieContainer.classList.toggle('hidden', !this.ties);
					this.updateShortcuts();
					this.show('battleSection');
					this.nextBattle();
				}

				calcScores(winner) {
					const [first,second] = this.pair;
					const isFirst = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
					const result = winner === 'tie' ? 0.5 : isFirst ? 1 : 0;
					const expected = 1 / (1 + 10 ** ((this.scores[second] - this.scores[first]) / 400));
					this.scores[first] += 32 * (result - expected);
					this.scores[second] += 32 * (expected - result);
				}

				choose(winner) {
					if (this.choosing)
						return;
					this.choosing = true;
					this.history.push({
						pair: this.pair,
						scores: [...this.scores],
						step: this.step,
						swapped: this.swapped
					});
					this.provider.mark(this.pair);
					this.calcScores(winner);
					this.step++;
					this.dom.undo.disabled = false;
					this.updateProgress();
					this.clearSelections();

					const button = winner === 'tie' ? this.dom.tie : this.dom[winner];
					button.classList.add('selected');
					setTimeout(()=>{
						this.choosing = false;
						this.nextBattle();
					}
					, 300);
				}

				displayBattle() {
					this.clearSelections();
					let[first,second] = this.pair;
					if (this.swapped)
						[first,second] = [second, first];
					this.dom.left.textContent = this.items[first];
					this.dom.right.textContent = this.items[second];
					this.updateProgress();
				}

				nextBattle() {
					this.clearSelections();
					const next = this.provider.next(this);
					if (!next)
						return this.showResults();
					this.pair = next;
					const key = this.provider.key(next);
					if (!this.swaps.has(key))
						this.swaps.set(key, Math.random() < 0.5);
					this.swapped = this.swaps.get(key);
					this.displayBattle();
				}

				updateProgress() {
					const value = this.provider ? this.provider.getProgressText(this.step) : '0';
					this.dom.progress.textContent = `${this.string('progress')}: ${value}`;
				}

				clearSelections() {
					['left', 'right', 'tie'].forEach(id=>this.dom[id].classList.remove('selected'));
				}

				showResults() {
					const results = this.provider.getResults(this.items, this.scores);
					this.dom.results.innerHTML = `<div class="results-header"><h2>${this.string('resultsTitle')}</h2></div>
					<table><thead><tr><th style="width:20%">${this.string('rank')}</th><th style="width:60%">${this.string('item')}</th><th style="width:20%">${this.string('score')}</th></tr></thead>
					<tbody>${results.map(r=>`<tr><td>${results.findIndex(x=>Math.round(x.score) === Math.round(r.score)) + 1}</td><td>${escape(r.item)}</td><td>${Math.round(r.score)}</td></tr>`).join('')}</tbody></table>`;
					this.show('results');
				}

				show(section) {
					['input', 'battleSection', 'results'].forEach(id=>this.dom[id].classList.toggle('hidden', id !== section));
					this.dom.restartContainer.classList.toggle('hidden', section !== 'results');
					this.dom.undo.classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
					this.keyboard = section === 'battleSection' || section === 'results';

					const undoPlacement = {
						battleSection: ()=>this.undoParent.insertBefore(this.dom.undo, this.undoSibling),
						results: ()=>this.dom.results.firstElementChild.prepend(this.dom.undo),
						input: ()=>{}
					};
					(undoPlacement[section] || (()=>{}
					))();
				}

				undoChoice() {
					if (this.choosing || !this.history.length)
						return;
					const last = this.history.pop();
					this.scores = last.scores;
					this.step = last.step;
					this.pair = last.pair;
					this.swapped = last.swapped;
					this.provider.unmark(last.pair);
					this.displayBattle();
					this.show('battleSection');
					this.dom.undo.disabled = !this.history.length;
				}

				restart() {
					this.initBattle();
					this.show('battleSection');
					this.nextBattle();
				}

				reset() {
					this.items = [];
					this.scores = [];
					this.pair = null;
					this.swapped = false;
					this.step = 0;
					this.ties = false;
					this.history = [];
					this.keyboard = false;
					this.choosing = false;
					this.provider = null;
					this.swaps = new Map();
					this.dom.items.value = '';
					this.dom.allowTies.checked = false;
					this.dom.quickRank.checked = false;
					this.show('input');
					this.updateShortcuts();
					this.updateProgress();
				}

				handleKey(event) {
					const tag = document.activeElement.tagName;
					if (!this.keyboard || ['SELECT', 'INPUT', 'TEXTAREA'].includes(tag))
						return;

					const map = {
						ArrowLeft: 'left',
						ArrowRight: 'right',
						ArrowUp: 'tie',
						ArrowDown: 'tie',
						z: 'undo',
						Z: 'undo'
					};
					const target = map[event.key];
					if (!target)
						return;

					const isUndo = event.key === 'z' || event.key === 'Z';
					const isArrow = event.key === 'ArrowUp' || event.key === 'ArrowDown';
					if (isUndo && !(event.ctrlKey || event.metaKey))
						return;
					if (isUndo && event.shiftKey)
						return;
					if (isArrow && !this.ties)
						return;

					event.preventDefault();
					this.dom[target].click();
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
