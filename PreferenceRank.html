<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--bg: #f9f9ff;
				--bg-container: #fff;
				--text: #414754;
				--border: #c1c6d7;
				--btn-hover: #d7d9e5
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--bg:#10131b;
					--bg-container: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--btn-hover: #10131b
				}
			}

			:root.dark {
				--bg: #10131b;
				--bg-container: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--btn-hover: #10131b
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--bg);
				color: var(--text);
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
				font-family: sans-serif
			}

			.container {
				background: var(--bg-container);
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0,0,0,.1);
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative
			}

			.container:has(#inputSection:not(.hidden)) {
				padding-top: 3rem
			}

			.hidden {
				display: none!important
			}

			h1,h2 {
				margin: .5rem 0;
				text-align: left
			}

			.form-group {
				margin-bottom: 1rem
			}

			label {
				display: block;
				font-weight: 700;
				margin-bottom: .5rem
			}

			input,select,textarea,button {
				background: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%
			}

			textarea {
				min-height: 80px;
				resize: vertical
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			.btn-primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.btn-primary:hover {
				background: var(--primary-hover)
			}

			.btn-secondary {
				background: var(--bg-container);
				color: var(--text)
			}

			.btn-secondary:hover {
				background: var(--btn-hover)
			}

			#battle,#restartButtons,#tieButtons {
				display: flex;
				gap: 1rem;
				margin-top: 1rem
			}

			#battle button,#tieButtons button,#restartButtons button {
				flex: 1
			}

			#battle button,#tieButtons button {
				font-size: 1.2rem;
				min-height: 100px
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center
			}

			#keyboardTip {
				background: var(--bg);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: .9;
				padding: 8px;
				text-align: center
			}

			#keyboardTip kbd {
				background: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px rgba(0,0,0,.2);
				display: inline-block;
				font-family: monospace;
				font-size: .9em;
				margin: 0 3px;
				padding: 2px 5px
			}

			#keyboardTipToggle {
				background: none;
				border: none;
				color: var(--primary);
				cursor: pointer;
				display: block;
				font-size: .85rem;
				margin: 10px auto 0;
				padding: 0;
				text-decoration: underline;
				width: auto
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px
			}

			.selectors select {
				font-size: .9rem;
				padding: 5px;
				width: auto
			}

			.checkbox {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 1rem
			}

			.checkbox input {
				width: auto
			}

			.checkbox label {
				margin: 0
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%
			}

			#results th,#results td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left
			}

			#results th {
				background: var(--primary);
				color: #fff
			}

			#undoButton {
				margin-top: 1rem;
				width: auto
			}

			#undoButton:disabled {
				background: var(--btn-hover);
				cursor: not-allowed
			}

			.selected {
				background: var(--primary)!important;
				color: #fff!important
			}

			#notification {
				background: var(--primary);
				color: #fff;
				padding: 1rem;
				border-radius: 4px;
				margin-bottom: 1rem;
				text-align: center
			}

			@media(max-width: 768px) {
				.container {
					padding:1.5rem
				}

				.container:has(#inputSection:not(.hidden)) {
					padding-top: calc(1.5rem + 1rem)
				}

				.selectors {
					gap: 4px;
					right: .5rem;
					top: .5rem
				}

				.selectors select {
					font-size: .8rem;
					padding: 4px
				}

				#battle,#tieButtons,#restartButtons {
					flex-direction: column
				}

				#battle button,#tieButtons button {
					width: 100%
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="notification" class="hidden"></div>
			<div id="inputSection">
				<h1 id="title"></h1>
				<div class="selectors">
					<select id="langSelect">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="themeSelect">
						<option value="auto" id="autoTheme"></option>
						<option value="light" id="lightTheme"></option>
						<option value="dark" id="darkTheme"></option>
					</select>
				</div>
				<div class="form-group">
					<label for="itemInput" id="itemInputLabel"></label>
					<textarea id="itemInput" rows="5" spellcheck="false"></textarea>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="allowTies"/>
					<label for="allowTies" id="allowTiesLabel"></label>
				</div>
				<div class="checkbox">
					<input type="checkbox" id="quickRank"/>
					<label for="quickRank" id="quickRankLabel"></label>
				</div>
				<button id="startButton" class="btn-primary"></button>
			</div>
			<div id="battleSection" class="hidden">
				<button id="undoButton" class="btn-secondary" disabled></button>
				<div id="battle">
					<button id="leftItem" class="btn-secondary"></button>
					<button id="rightItem" class="btn-secondary"></button>
				</div>
				<div id="tieButtons" class="hidden">
					<button id="tieButton" class="btn-secondary"></button>
				</div>
				<div id="progress"></div>
				<button id="keyboardTipToggle"></button>
				<div id="keyboardTip" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartButtons" class="hidden">
				<button id="restartBattleButton" class="btn-primary"></button>
				<button id="restartNewButton" class="btn-primary"></button>
			</div>
		</div>
		<script>
			const $ = id=>document.getElementById(id);
			const trans = {
				en: {
					title: "PreferenceRank",
					autoTheme: "Auto Theme",
					lightTheme: "Light",
					darkTheme: "Dark",
					itemInputLabel: "Enter items, one per line:",
					allowTiesLabel: "Allow Ties",
					quickRankLabel: "Use Quick Rank (fewer comparisons)",
					alert: "Please enter at least two items.",
					duplicateAlert: "{count} duplicate item(s) were found and have been removed.",
					startButton: "Start Ranking",
					tieButton: "It's a Tie",
					undoButton: "Undo",
					progress: "Progress",
					keyboardTipToggle: "Show keyboard shortcuts",
					keyboardTipHide: "Hide keyboard shortcuts",
					keyboardTipWithTies: "Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> or <kbd>↓</kbd> It's a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice",
					keyboardTipNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
					results: "Results",
					rank: "Rank",
					item: "Item",
					score: "Score",
					restartBattleButton: "Restart Battle",
					restartNewButton: "Start with New Items"
				},
				id: {
					title: "PreferenceRank",
					autoTheme: "Tema Otomatis",
					lightTheme: "Terang",
					darkTheme: "Gelap",
					itemInputLabel: "Masukkan pilihan, satu per baris:",
					allowTiesLabel: "Izinkan Seri",
					quickRankLabel: "Gunakan Peringkat Cepat (lebih sedikit perbandingan)",
					alert: "Harap masukkan setidaknya dua pilihan.",
					duplicateAlert: "{count} item duplikat ditemukan dan telah dihapus.",
					startButton: "Mulai Peringkat",
					tieButton: "Seri",
					undoButton: "Urungkan",
					progress: "Kemajuan",
					keyboardTipToggle: "Tampilkan pintasan papan ketik",
					keyboardTipHide: "Sembunyikan pintasan papan ketik",
					keyboardTipWithTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> atau <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					keyboardTipNoTies: "Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir",
					results: "Hasil",
					rank: "Peringkat",
					item: "Nama",
					score: "Skor",
					restartBattleButton: "Mulai Ulang Pertarungan",
					restartNewButton: "Mulai dengan Pilihan Baru"
				}
			};
			class PairProvider {
				constructor(n) {
					this.n = n
				}
				static shuffle(arr) {
					for (let i = arr.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[arr[i],arr[j]] = [arr[j], arr[i]]
					}
				}
				markAsCompared() {}
				unmarkAsCompared() {}
			}
			class FullPairProvider extends PairProvider {
				constructor(n) {
					super(n);
					this.pairs = [];
					for (let i = 0; i < n - 1; i++)
						for (let j = i + 1; j < n; j++) this.pairs.push([i, j]);
					PairProvider.shuffle(this.pairs)
				}
				getNextPair(state) {
					return this.pairs[state.progress]
				}
				getTotal() {
					return this.pairs.length
				}
			}
			class QuickPairProvider extends PairProvider {
				constructor(n) {
					super(n);
					this.compared = new Set
				}
				getNextPair(state) {
					const sorted = Array.from({
						length: this.n
					}, (_,i)=>i).sort((a,b)=>state.scores[b] - state.scores[a]);
					for (let i = 0; i < this.n - 1; i++) {
						const p1 = sorted[i],
							p2 = sorted[i + 1],
							pair = [Math.min(p1, p2), Math.max(p1, p2)],
							key = `${pair[0]}-${pair[1]}`;
						if (!this.compared.has(key)) return pair
					}
					return null
				}
				markAsCompared(pair) {
					this.compared.add(`${pair[0]}-${pair[1]}`)
				}
				unmarkAsCompared(pair) {
					this.compared.delete(`${pair[0]}-${pair[1]}`)
				}
			}
			class PreferenceRank {
				constructor() {
					this.state = this.getInitialState();
					this.init()
				}
				getInitialState(preserve={}) {
					return {
						items: [],
						scores: [],
						currentPair: null,
						isSwapped: !1,
						progress: 0,
						total: 0,
						allowTies: !1,
						history: [],
						keyboardEnabled: !1,
						isChoosing: !1,
						lang: preserve.lang || (navigator.language?.startsWith("id") ? "id" : "en"),
						theme: preserve.theme || "auto"
					}
				}
				t(key, replacements={}) {
					let text = trans[this.state.lang][key] || key;
					Object.entries(replacements).forEach(([p,v])=>text = text.replace(`{${p}}`, v));
					return text
				}
				init() {
					this.ui = {};
					["langSelect", "themeSelect", "allowTies", "quickRank", "startButton", "leftItem", "rightItem", "tieButton", "restartBattleButton", "restartNewButton", "undoButton", "keyboardTipToggle", "inputSection", "battleSection", "results", "restartButtons", "tieButtons", "keyboardTip", "progress", "itemInput", "title", "autoTheme", "lightTheme", "darkTheme", "itemInputLabel", "allowTiesLabel", "quickRankLabel", "notification"].forEach(id=>this.ui[id] = $(id));
					this.bindEventListeners();
					this.ui.langSelect.value = this.state.lang;
					this.applyTheme();
					this.updateLang()
				}
				bindEventListeners() {
					const listeners = {
						langSelect: {
							change: ()=>this.updateLang()
						},
						themeSelect: {
							change: e=>{
								this.state.theme = e.target.value;
								this.applyTheme()
							}
						},
						allowTies: {
							change: e=>{
								this.state.allowTies = e.target.checked;
								if (!this.ui.battleSection.classList.contains("hidden")) {
									this.ui.tieButtons.classList.toggle("hidden", !this.state.allowTies);
									this.updateKeyboardTip()
								}
							}
						},
						startButton: {
							click: ()=>this.start()
						},
						leftItem: {
							click: ()=>this.choose("left")
						},
						rightItem: {
							click: ()=>this.choose("right")
						},
						tieButton: {
							click: ()=>this.choose("tie")
						},
						restartBattleButton: {
							click: ()=>this.restartBattle()
						},
						restartNewButton: {
							click: ()=>this.restartNew()
						},
						undoButton: {
							click: ()=>this.undo()
						},
						keyboardTipToggle: {
							click: ()=>this.toggleKeyboardTip()
						}
					};
					for (const elementId in listeners)
						for (const event in listeners[elementId]) this.ui[elementId].addEventListener(event, listeners[elementId][event]);
					document.addEventListener("keydown", e=>this.handleKeyDown(e))
				}
				applyTheme() {
					document.documentElement.classList.remove("light", "dark");
					if (this.state.theme !== "auto") document.documentElement.classList.add(this.state.theme)
				}
				updateLang() {
					this.state.lang = this.ui.langSelect.value;
					["title", "autoTheme", "lightTheme", "darkTheme", "itemInputLabel", "allowTiesLabel", "quickRankLabel", "startButton", "tieButton", "undoButton", "restartBattleButton", "restartNewButton"].forEach(key=>this.ui[key].textContent = this.t(key));
					this.updateKeyboardTip();
					this.ui.keyboardTipToggle.textContent = this.t(this.ui.keyboardTip.classList.contains("hidden") ? "keyboardTipToggle" : "keyboardTipHide");
					this.updateProgress();
					if (!this.ui.results.classList.contains("hidden")) this.showResults()
				}
				updateKeyboardTip() {
					this.ui.keyboardTip.innerHTML = this.t(this.state.allowTies ? "keyboardTipWithTies" : "keyboardTipNoTies")
				}
				showNotification(message, duration=3e3) {
					this.ui.notification.textContent = message;
					this.ui.notification.classList.remove("hidden");
					setTimeout(()=>this.ui.notification.classList.add("hidden"), duration)
				}
				parseItems() {
					const raw = this.ui.itemInput.value.split("\n").map(s=>s.trim()).filter(Boolean),
						items = [...new Set(raw)],
						removedCount = raw.length - items.length;
					if (removedCount > 0) this.showNotification(this.t("duplicateAlert", {
						count: removedCount
					}));
					return items
				}
				start() {
					const items = this.parseItems();
					if (items.length < 2) return this.showNotification(this.t("alert"));
					this.state.items = items;
					this.state.allowTies = this.ui.allowTies.checked;
					this.resetBattle();
					this.ui.tieButtons.classList.toggle("hidden", !this.state.allowTies);
					this.toggleKeyboardTip(true);
					this.updateKeyboardTip();
					this.showSection("battleSection");
					this.nextBattle()
				}
				resetBattle() {
					const n = this.state.items.length;
					this.state.scores = Array(n).fill(1e3);
					this.state.progress = 0;
					this.state.history = [];
					this.ui.undoButton.disabled = true;
					this.state.pairProvider = this.ui.quickRank.checked ? new QuickPairProvider(n) : new FullPairProvider(n);
					this.state.total = this.ui.quickRank.checked ? 0 : this.state.pairProvider.getTotal()
				}
				updateScores(winner) {
					const {
						currentPair,
						isSwapped,
						scores
					} = this.state, p1Wins = winner === "left" && !isSwapped || winner === "right" && isSwapped, result = winner === "tie" ? .5 : p1Wins ? 1 : 0, [i1,i2] = currentPair, [s1,s2] = [scores[i1], scores[i2]], expected1 = 1 / (1 + 10 ** ((s2 - s1) / 400)), k = 32;
					scores[i1] += k * (result - expected1);
					scores[i2] += k * (expected1 - result)
				}
				choose(winner) {
					if (this.state.isChoosing) return;
					this.state.isChoosing = true;
					this.state.history.push({
						pair: this.state.currentPair,
						scores: [...this.state.scores],
						progressBefore: this.state.progress
					});
					this.state.pairProvider.markAsCompared(this.state.currentPair);
					this.updateScores(winner);
					this.state.progress++;
					this.ui.undoButton.disabled = false;
					this.updateProgress();
					this.animateChoice(winner)
				}
				animateChoice(winner) {
					this.clearSelections();
					const targetButton = winner === "tie" ? this.ui.tieButton : this.ui[`${winner}Item`];
					targetButton.classList.add("selected");
					setTimeout(()=>{
						this.state.isChoosing = false;
						this.nextBattle()
					}, 300)
				}
				nextBattle() {
					this.clearSelections();
					const nextPair = this.state.pairProvider.getNextPair(this.state);
					if (!nextPair || !this.ui.quickRank.checked && this.state.progress >= this.state.total) return this.showResults();
					this.state.currentPair = nextPair;
					let [i1,i2] = nextPair;
					this.state.isSwapped = Math.random() < .5;
					if (this.state.isSwapped)[i1,i2] = [i2, i1];
					this.ui.leftItem.textContent = this.state.items[i1];
					this.ui.rightItem.textContent = this.state.items[i2];
					this.updateProgress()
				}
				updateProgress() {
					const text = this.ui.quickRank.checked ? `${this.t("progress")}: ${this.state.progress}` : `${this.t("progress")}: ${this.state.progress}/${this.state.total}`;
					this.ui.progress.textContent = text
				}
				clearSelections() {
					["leftItem", "rightItem", "tieButton"].forEach(id=>this.ui[id].classList.remove("selected"))
				}
				showResults() {
					const sorted = this.state.items.map((item,i)=>({
						item,
						score: this.state.scores[i]
					})).sort((a,b)=>b.score - a.score);
					this.ui.results.innerHTML = `<h2>${this.t("results")}</h2><table><thead><tr><th style="width:20%">${this.t("rank")}</th><th style="width:60%">${this.t("item")}</th><th style="width:20%">${this.t("score")}</th></tr></thead><tbody>${sorted.map(({item,score},i)=>`<tr><td>${i+1}</td><td>${item}</td><td>${Math.round(score)}</td></tr>`).join("")}</tbody></table>`;
					this.showSection("results")
				}
				showSection(section) {
					["inputSection", "battleSection", "results"].forEach(id=>this.ui[id].classList.toggle("hidden", id !== section));
					this.ui.restartButtons.classList.toggle("hidden", section !== "results");
					this.state.keyboardEnabled = section === "battleSection"
				}
				undo() {
					if (this.state.isChoosing || !this.state.history.length) return;
					const last = this.state.history.pop();
					this.state.scores = last.scores;
					this.state.progress = last.progressBefore;
					this.state.pairProvider.unmarkAsCompared(last.pair);
					this.nextBattle();
					this.ui.undoButton.disabled = !this.state.history.length
				}
				restartBattle() {
					this.resetBattle();
					this.showSection("battleSection");
					this.nextBattle()
				}
				restartNew() {
					this.state = this.getInitialState({
						lang: this.state.lang,
						theme: this.state.theme
					});
					this.ui.langSelect.value = this.state.lang;
					this.ui.itemInput.value = "";
					this.ui.allowTies.checked = false;
					this.ui.quickRank.checked = false;
					this.showSection("inputSection");
					this.updateLang()
				}
				toggleKeyboardTip(forceHide) {
					const hidden = this.ui.keyboardTip.classList.toggle("hidden", forceHide);
					this.ui.keyboardTipToggle.textContent = this.t(hidden ? "keyboardTipToggle" : "keyboardTipHide")
				}
				handleKeyDown(e) {
					if (!this.state.keyboardEnabled || ["SELECT", "INPUT", "TEXTAREA"].includes(document.activeElement.tagName)) return;
					const keyMap = {
						ArrowLeft: ()=>this.ui.leftItem.click(),
						ArrowRight: ()=>this.ui.rightItem.click(),
						ArrowUp: ()=>this.state.allowTies && this.ui.tieButton.click(),
						ArrowDown: ()=>this.state.allowTies && this.ui.tieButton.click(),
						z: ()=>(e.ctrlKey || e.metaKey) && this.ui.undoButton.click()
					};
					if (keyMap[e.key]) {
						e.preventDefault();
						keyMap[e.key]()
					}
				}
			}
			new PreferenceRank;
		</script>
	</body>
</html>
