<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>PreferenceRank</title>
		<style>
			:root {
				--primary: #0070ea;
				--hover: #005bc0;
				--bg: #f9f9ff;
				--surface: #fff;
				--text: #414754;
				--border: #c1c6d7;
				--dim: #d7d9e5;
				--success: #28a745;
				--danger: #dc3545
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--bg:#10131b;
					--surface: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--dim: #10131b
				}
			}

			:root.dark {
				--bg: #10131b;
				--surface: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--dim: #10131b
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			*:focus-visible {
				outline: 2px solid var(--primary);
				outline-offset: 2px
			}

			#battle button:focus-visible,#tieWrap button:focus-visible {
				outline: none
			}

			body {
				background: var(--bg);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem
			}

			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 720px;
				padding: 2rem;
				width: 100%;
				position: relative
			}

			.hidden {
				display: none!important
			}

			h1,h2,label {
				margin-bottom: .5rem;
				display: block
			}

			h1,h2 {
				margin-top: .5rem
			}

			label {
				font-weight: 700
			}

			input,select,textarea,button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%
			}

			textarea {
				min-height: 80px;
				resize: vertical
			}

			button {
				cursor: pointer;
				transition: background .1s
			}

			button:disabled {
				background: var(--dim)!important;
				border-color: var(--border)!important;
				color: var(--text)!important;
				cursor: not-allowed;
				opacity: .6
			}

			#copy {
				width: auto
			}

			.primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.primary:hover:not(:disabled) {
				background: var(--hover)
			}

			.secondary:hover:not(:disabled) {
				background: var(--dim)
			}

			.count {
				color: var(--text);
				font-size: .85rem;
				margin-top: .25rem;
				text-align: right;
				opacity: .8
			}

			.error {
				color: var(--danger);
				font-size: .9rem;
				margin-top: .5rem;
				display: block
			}

			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px
			}

			.selectors select {
				font-size: .9rem;
				padding: 5px;
				width: auto
			}

			.checkbox-row {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: .75rem 0
			}

			.checkbox-row input {
				width: auto
			}

			.checkbox-row label {
				margin: 0
			}

			#battle,#tieWrap,#restartWrap {
				display: flex;
				gap: 1rem;
				margin-top: 1rem
			}

			#battle button,#tieWrap button,#restartWrap button {
				flex: 1
			}

			#battle button,#tieWrap button {
				font-size: 1.2rem;
				min-height: 100px
			}

			#progress {
				font-size: 1.1rem;
				margin-top: 1rem;
				text-align: center
			}

			.progress-track {
				background: var(--dim);
				border-radius: 4px;
				height: 6px;
				margin: 8px auto 0;
				max-width: 200px;
				overflow: hidden;
				width: 100%
			}

			#progressFill {
				background: var(--primary);
				height: 100%;
				transition: width .3s ease;
				width: 0%
			}

			#tips {
				background: var(--bg);
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .85rem;
				line-height: 1.5;
				margin-top: 15px;
				opacity: .9;
				padding: 8px;
				text-align: center
			}

			kbd {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 3px;
				box-shadow: 0 1px 1px #0003;
				display: inline-block;
				font-family: monospace;
				font-size: .9em;
				margin: 0 3px;
				padding: 2px 5px
			}

			#cancel,#toggle {
				background: none;
				border: 1px solid var(--border);
				color: var(--text);
				cursor: pointer;
				display: block;
				font-size: .9rem;
				margin: 1rem auto;
				padding: 5px 15px;
				width: auto
			}

			#cancel:hover {
				background: var(--dim)
			}

			#cancel.confirming {
				border-color: var(--danger);
				color: var(--danger)
			}

			#toggle {
				border: none;
				color: var(--primary);
				font-size: .85rem;
				margin-top: 10px;
				text-decoration: underline
			}

			#results table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%
			}

			#results th,#results td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left
			}

			#results th {
				background: var(--primary);
				color: #fff
			}

			.results-header {
				display: flex;
				justify-content: center;
				align-items: center;
				position: relative;
				min-height: 40px;
				margin-bottom: 1rem
			}

			.results-header h2 {
				margin: 0
			}

			.results-header #undo {
				position: absolute;
				left: 0;
				top: 50%;
				transform: translateY(-50%)
			}

			.results-header #copy {
				position: absolute;
				right: 0;
				top: 50%;
				transform: translateY(-50%)
			}

			#undo {
				width: auto
			}

			.selected {
				background: var(--primary)!important;
				color: #fff!important
			}

			@media(max-width: 768px) {
				body {
					padding:.75rem
				}

				.container {
					padding: 1.5rem
				}

				.selectors {
					position: static;
					justify-content: flex-end;
					margin-bottom: .5rem;
					gap: 4px
				}

				.selectors select {
					font-size: .8rem;
					padding: 4px
				}

				#battle,#tieWrap,#restartWrap {
					flex-direction: column
				}

				#battle button,#tieWrap button {
					width: 100%
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="inputSection">
				<div class="selectors">
					<select id="language" aria-label="Language">
						<option value="en">English</option>
						<option value="id">Bahasa Indonesia</option>
					</select>
					<select id="theme" aria-label="Theme">
						<option value="auto"></option>
						<option value="light"></option>
						<option value="dark"></option>
					</select>
				</div>
				<h1 id="title"></h1>
				<div class="group">
					<label for="items" id="labelItems"></label>
					<textarea id="items" rows="5" spellcheck="false" autofocus></textarea>
					<div id="itemCount" class="count"></div>
					<span id="error" class="error hidden" aria-live="polite"></span>
				</div>
				<div class="checkbox-row">
					<input type="checkbox" id="allowTies">
					<label for="allowTies" id="labelTies"></label>
				</div>
				<div class="checkbox-row">
					<input type="checkbox" id="quickRank">
					<label for="quickRank" id="labelQuick"></label>
				</div>
				<button id="start" class="primary"></button>
			</div>
			<button id="undo" class="secondary hidden" disabled></button>
			<button id="copy" class="secondary hidden"></button>
			<div id="battleSection" class="hidden">
				<div id="battle">
					<button id="left" class="secondary"></button>
					<button id="right" class="secondary"></button>
				</div>
				<div id="tieWrap" class="hidden">
					<button id="tie" class="secondary"></button>
				</div>
				<div id="progress"></div>
				<div class="progress-track"><div id="progressFill"></div></div>
				<button id="cancel"></button>
				<button id="toggle" aria-controls="tips" aria-expanded="false"></button>
				<div id="tips" class="hidden"></div>
			</div>
			<div id="results" class="hidden"></div>
			<div id="restartWrap" class="hidden">
				<button id="restartBattle" class="primary"></button>
				<button id="restartNew" class="primary"></button>
			</div>
		</div>
		<script>
			const text = {
				en: {
					title: 'PreferenceRank',
					languageLabel: 'Language',
					themeLabel: 'Theme',
					auto: 'Auto Theme',
					light: 'Light',
					dark: 'Dark',
					labelItems: 'Enter items, one per line:',
					labelTies: 'Allow Ties',
					labelQuick: 'Use Quick Rank (fewer comparisons)',
					alert: 'Please enter at least two items.',
					duplicate: '{count} duplicate item(s) removed.',
					itemsCount: '{count} items',
					start: 'Start Ranking',
					cancel: 'Cancel',
					confirmCancel: 'Confirm Cancel?',
					tie: "It's a Tie",
					undo: 'Undo',
					progress: 'Progress',
					toggleShow: 'Show keyboard shortcuts',
					toggleHide: 'Hide keyboard shortcuts',
					tipTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>↑</kbd>/<kbd>↓</kbd> Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
					tipNoTie: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left<br><kbd>→</kbd> Choose right<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo',
					resultsTitle: 'Results',
					rank: 'Rank',
					item: 'Item',
					score: 'Score',
					restartBattle: 'Restart Battle',
					restartNew: 'Edit Items',
					placeholderItems: 'Apple\nBlueberry\nCherry',
					copy: 'Copy Results',
					copied: 'Copied!'
				},
				id: {
					title: 'PreferenceRank',
					languageLabel: 'Bahasa',
					themeLabel: 'Tema',
					auto: 'Tema Otomatis',
					light: 'Terang',
					dark: 'Gelap',
					labelItems: 'Masukkan pilihan, satu per baris:',
					labelTies: 'Izinkan Seri',
					labelQuick: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
					alert: 'Harap masukkan setidaknya dua pilihan.',
					duplicate: '{count} item duplikat dihapus.',
					itemsCount: '{count} pilihan',
					start: 'Mulai Peringkat',
					cancel: 'Batal',
					confirmCancel: 'Konfirmasi Batal?',
					tie: 'Seri',
					undo: 'Urungkan',
					progress: 'Kemajuan',
					toggleShow: 'Tampilkan pintasan papan ketik',
					toggleHide: 'Sembunyikan pintasan papan ketik',
					tipTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>↑</kbd>/<kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
					tipNoTie: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih kiri<br><kbd>→</kbd> Pilih kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan',
					resultsTitle: 'Hasil',
					rank: 'Peringkat',
					item: 'Nama',
					score: 'Skor',
					restartBattle: 'Mulai Ulang Pertarungan',
					restartNew: 'Ubah Pilihan',
					placeholderItems: 'Apel\nBluberi\nCeri',
					copy: 'Salin Hasil',
					copied: 'Disalin!'
				}
			};

			const escape = t=>t.replace(/[&<>"']/g, c=>'&#' + c.charCodeAt(0) + ';');
			const dom = Object.fromEntries([...document.querySelectorAll('[id]')].map(e=>[e.id, e]));

			class PairProvider{constructor(c){this.count=c;this.compared=new Set}key([a,b]){return a<b?`${a}-${b}`:`${b}-${a}`}mark(p){this.compared.add(this.key(p))}unmark(p){this.compared.delete(this.key(p))}getRanking(s){return[...s.keys()].sort((a,b)=>s[b]-s[a])}}

			class FullPairProvider extends PairProvider{constructor(c){super(c);this.pairs=[];for(let i=0;i<c-1;i++)for(let j=i+1;j<c;j++)this.pairs.push([i,j]);for(let i=this.pairs.length;i--;){const j=Math.floor(Math.random()*(i+1));[this.pairs[i],this.pairs[j]]=[this.pairs[j],this.pairs[i]]}}next(s){return this.pairs[s.step]}getProgress(s){return`${s}/${this.pairs.length}`}}

			class QuickPairProvider extends PairProvider{constructor(c){super(c);this.S=[{s:'init',items:[...Array(c).keys()]}];this.H=[];this.P=this.F=null;this.R={p:0,i:0,s:!1};this.J=[0,1];while(this.J.at(-1)<c)this.J.push(this.J.at(-1)+2*this.J.at(-2))}snap(){return structuredClone({S:this.S,P:this.P,F:this.F,R:this.R})}rest(s){Object.assign(this,structuredClone(s))}unmark(p){this.P&&this.H.length&&this.H.pop();this.H.length&&this.rest(this.H.at(-1));super.unmark(p)}next(s,r){this.P&&this.hP(s,r);while(this.S.length){const f=this.S.at(-1),o=this[f.s](f);if(o)return o}return this.F?this.hR():null}hP(s,r){const[a,b]=this.P,w=r===.5?(s.swapped?b:a):r===1?a:b;this.S.at(-1)&&(this.S.at(-1).lw=w);this.F&&this.hRS(a,b,w);this.P=null}hRS(a,b,w){const i=this.F.indexOf(a);if(w===b&&i!==-1&&this.F[i+1]===b){[this.F[i],this.F[i+1]]=[this.F[i+1],this.F[i]];this.R.s=!0}this.R.i++}init(f){if(f.items.length<2)return this.ret(f.items);f.pairs=Array.from({length:f.items.length>>1},(_,i)=>[f.items[2*i],f.items[2*i+1]]);f.odd=f.items.length%2?f.items.at(-1):null;Object.assign(f,{win:[],lose:[],pi:0,s:'cmp'})}cmp(f){if(f.pi>=f.pairs.length){f.s='rec';this.S.push({s:'init',items:[...f.win]});return null}if(f.lw!==undefined){f.win.push(f.lw);const[a,b]=f.pairs[f.pi];f.lose.push(f.lw===a?b:a);delete f.lw;f.pi++;return null}this.P=f.pairs[f.pi];this.H.push(this.snap());return this.P}rec(f){if(!f.sub)return null;f.main=f.sub;delete f.sub;f.map={};f.win.forEach((w,i)=>f.map[w]=f.lose[i]);f.main.unshift(f.map[f.main[0]]);f.ins=[];f.main.slice(1).forEach((w,i)=>i>0&&f.ins.push({item:f.map[w],bound:w}));f.odd!==null&&f.ins.push({item:f.odd,bound:null});f.ji=2;f.grp=[];f.s='grp'}grp(f){if(!f.grp.length){if(this.J[f.ji-1]-1>=f.ins.length)return this.ret(f.main);const s=this.J[f.ji-1]-1,e=Math.min(this.J[f.ji]-2,f.ins.length-1);f.grp.push(...f.ins.slice(s,e+1).reverse());f.ji++}if(f.main===this.F)return null;if(f.grp.length){f.curr=f.grp.shift();f.s='ins';f.bs={min:0,max:f.curr.bound!==null?f.main.indexOf(f.curr.bound):f.main.length,t:f.curr.item}}}ins(f){const{min,max,t}=f.bs;if(min>=max){f.main.splice(min,0,t);f.s='grp';return null}if(f.lw!==undefined){f.lw===t?f.bs.min=f.bs.mid+1:f.bs.max=f.bs.mid;delete f.lw;return null}f.bs.mid=(min+max)>>1;this.P=[t,f.main[f.bs.mid]];this.H.push(this.snap());return this.P}hR(){while(1){if(this.R.p>=2)return null;if(this.R.i>=this.F.length-1){if(!this.R.s)return null;this.R.p++;this.R.i=0;this.R.s=!1;continue}const[a,b]=[this.F[this.R.i],this.F[this.R.i+1]];if(!this.compared.has(this.key([a,b]))){this.P=[a,b];this.H.push(this.snap());return this.P}this.R.i++}}ret(r){this.S.pop();this.S.length?this.S.at(-1).sub=r:this.F=r.reverse()}getProgress(s){return`${s}/~${Math.round(.78*this.count*Math.log2(this.count))}`}}

			class PreferenceRank {
				init() {
					Object.assign(this, {
						items: [],
						scores: [],
						matches: [],
						pair: null,
						swapped: false,
						step: 0,
						allowTies: false,
						history: [],
						keyboardEnabled: false,
						busy: false,
						swaps: new Map(),
						provider: null,
						cancelTimeout: null
					});
				}

				constructor() {
					this.init();
					this.language = navigator.language.startsWith('id') ? 'id' : 'en';
					this.bind();
					this.setTheme('auto');
					this.updateText();
					this.checkStartButton();
					this.updateItemCount();
					this.loadState();
				}

				saveState() {
					const data = {
						inputValue: dom.items.value,
						battle: null
					};
					if (dom.inputSection.classList.contains('hidden')) {
						data.battle = {
							items: this.items,
							scores: this.scores,
							matches: this.matches,
							pair: this.pair,
							swapped: this.swapped,
							step: this.step,
							allowTies: this.allowTies,
							history: this.history,
							swaps: this.swaps,
							providerType: this.provider instanceof QuickPairProvider ? 'quick' : 'full',
							provider: this.provider
						};
					}
					try {
						localStorage.setItem('preferenceRankData', JSON.stringify(data, (k, v) => v instanceof Map ? {__type: 'Map', value: [...v]} : v instanceof Set ? {__type: 'Set', value: [...v]} : v));
					} catch (e) {
						console.error('Failed to save state', e);
					}
				}

				loadState() {
					const raw = localStorage.getItem('preferenceRankData');
					if (!raw)
						return;
					try {
						const data = JSON.parse(raw, (k, v) => v?.__type === 'Map' ? new Map(v.value) : v?.__type === 'Set' ? new Set(v.value) : v);
						if (data.inputValue) {
							dom.items.value = data.inputValue;
							this.checkStartButton();
							this.updateItemCount();
						}
						if (data.battle) {
							Object.assign(this, data.battle);
							const ProviderClass = data.battle.providerType === 'quick' ? QuickPairProvider : FullPairProvider;
							this.provider = new ProviderClass(this.items.length);
							Object.assign(this.provider, data.battle.provider);
							dom.allowTies.checked = this.allowTies;
							dom.quickRank.checked = data.battle.providerType === 'quick';
							this.setTies(this.allowTies);
							if (this.pair) {
								this.show('battleSection');
								this.renderPair();
								this.updateProgress();
								dom.undo.disabled = !this.history.length;
							} else if (this.matches.length > 0) {
								this.renderResults();
							} else {
								this.show('inputSection');
							}
						}
					} catch (e) {
						console.error('Failed to load state', e);
						localStorage.removeItem('preferenceRankData');
					}
				}

				saveInput() {
					if (this.saveTimeout)
						clearTimeout(this.saveTimeout);
					this.saveTimeout = setTimeout(()=>this.saveState(), 500);
				}

				getItems() {
					return dom.items.value.split('\n').map(line=>line.trim()).filter(Boolean);
				}
				string(key) {
					return text[this.language]?.[key] ?? key;
				}

				bind() {
					Object.entries({
						start: this.start,
						restartBattle: this.start,
						restartNew: this.reset,
						undo: this.undo,
						copy: this.copyResults,
						toggle: this.toggleHelp,
						cancel: this.cancel,
						left: ()=>this.choose('left'),
						right: ()=>this.choose('right'),
						tie: ()=>this.choose('tie')
					}).forEach(([id,handler])=>dom[id].onclick = handler.bind(this));
					dom.language.onchange = e=>{
						this.language = e.target.value;
						this.updateText();
					}
					;
					dom.theme.onchange = e=>this.setTheme(e.target.value);
					dom.allowTies.onchange = e=>this.setTies(e.target.checked);
					dom.items.oninput = ()=>{
						this.checkStartButton();
						this.updateItemCount();
						this.saveInput();
					}
					;
					document.onkeydown = e=>this.handleKey(e);
				}

				setTheme(theme) {
					document.documentElement.className = theme === 'auto' ? '' : theme;
					dom.theme.value = theme;
				}

				updateText() {
					dom.language.value = this.language;
					dom.language.setAttribute('aria-label', this.string('languageLabel'));
					dom.theme.setAttribute('aria-label', this.string('themeLabel'));
					dom.items.placeholder = this.string('placeholderItems');
					['title', 'labelItems', 'labelTies', 'labelQuick', 'start', 'cancel', 'tie', 'undo', 'copy', 'restartBattle', 'restartNew'].forEach(key=>dom[key].textContent = this.string(key));
					dom.start.title = `${this.string('start')} (Ctrl/⌘ + Enter)`;
					[...dom.theme.options].forEach(option=>option.textContent = this.string(option.value));
					this.updateHelp();
					this.updateProgress();
					this.updateItemCount();
					!dom.results.classList.contains('hidden') && this.renderResults();
				}

				updateItemCount() {
					const count = this.getItems().length;
					dom.itemCount.textContent = this.string('itemsCount').replace('{count}', count);
				}

				setTies(enabled) {
					this.allowTies = enabled;
					!dom.battleSection.classList.contains('hidden') && dom.tieWrap.classList.toggle('hidden', !enabled);
					this.updateHelp();
				}

				updateHelp() {
					const hidden = dom.tips.classList.contains('hidden');
					dom.toggle.textContent = this.string(hidden ? 'toggleShow' : 'toggleHide');
					dom.toggle.setAttribute('aria-expanded', !hidden);
					dom.tips.innerHTML = this.string(this.allowTies ? 'tipTie' : 'tipNoTie');
				}

				toggleHelp() {
					dom.tips.classList.toggle('hidden');
					this.updateHelp();
				}
				checkStartButton() {
					const valid = new Set(this.getItems()).size >= 2;
					dom.start.disabled = !valid;
					valid && dom.error.classList.add('hidden');
				}

				start() {
					const raw = this.getItems();
					const unique = [...new Set(raw)];
					if (raw.length > unique.length) {
						dom.items.value = unique.join('\n');
						dom.error.textContent = this.string('duplicate').replace('{count}', raw.length - unique.length);
						dom.error.classList.remove('hidden');
						return;
					}
					Object.assign(this, {
						items: unique,
						allowTies: dom.allowTies.checked,
						scores: Array(unique.length).fill(1000),
						matches: [],
						step: 0,
						history: [],
						swaps: new Map(),
						busy: false
					});
					dom.undo.disabled = true;
					this.provider = new (dom.quickRank.checked ? QuickPairProvider : FullPairProvider)(unique.length);
					dom.tieWrap.classList.toggle('hidden', !this.allowTies);
					this.updateHelp();
					this.show('battleSection');
					this.next();
					this.saveState();
				}

				recalculateScores() {
					const steps = 5
					  , scores = Array(this.items.length).fill(1000);
					const factor = Math.log(10) / 400
					  , k = 32 / steps;
					for (let step = 0; step < steps; step++) {
						const deltas = Array(this.items.length).fill(0);
						this.matches.forEach(({a, b, result})=>{
							const expected = 1 / (1 + Math.exp((scores[b] - scores[a]) * factor));
							const change = k * (result - expected);
							deltas[a] += change;
							deltas[b] -= change;
						}
						);
						scores.forEach((_,i)=>scores[i] += deltas[i]);
					}
					this.scores = scores;
				}

				choose(winner) {
					if (this.busy || dom.battleSection.classList.contains('hidden'))
						return;
					this.busy = true;
					this.history.push({
						pair: this.pair,
						scores: [...this.scores],
						step: this.step,
						swapped: this.swapped
					});
					this.provider.mark(this.pair);
					const [a,b] = this.pair;
					const isLeftWinner = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
					const result = winner === 'tie' ? 0.5 : isLeftWinner ? 1 : 0;
					this.matches.push({
						a,
						b,
						result
					});
					this.recalculateScores();
					this.step++;
					dom.undo.disabled = false;
					this.updateProgress();
					this.clearSelections();
					(winner === 'tie' ? dom.tie : dom[winner]).classList.add('selected');
					setTimeout(()=>{
						if (dom.battleSection.classList.contains('hidden') || !this.busy)
							return;
						this.busy = false;
						this.next(result);
						this.saveState();
					}
					, 150);
				}

				next(result) {
					this.clearSelections();
					const nextPair = this.provider.next(this, result);
					if (!nextPair)
						return this.renderResults();
					this.pair = nextPair;
					const key = this.provider.key(nextPair);
					this.swaps.has(key) || this.swaps.set(key, Math.random() < 0.5);
					this.swapped = this.swaps.get(key);
					this.renderPair();
				}

				renderPair() {
					let[a,b] = this.pair;
					this.swapped && ([a,b] = [b, a]);
					dom.left.textContent = this.items[a];
					dom.right.textContent = this.items[b];
					this.updateProgress();
				}

				updateProgress() {
					const text = this.provider ? this.provider.getProgress(this.step) : '0';
					dom.progress.textContent = `${this.string('progress')}: ${text}`;
					let percent = 0;
					if (this.provider) {
						const [curr, total] = text.split('/');
						const t = parseInt(total.replace('~', ''), 10);
						if (t > 0) percent = (parseInt(curr, 10) / t) * 100;
					}
					dom.progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
				}
				clearSelections() {
					['left', 'right', 'tie'].forEach(id=>dom[id].classList.remove('selected'));
				}

				renderResults() {
					const ranking = this.provider.getRanking(this.scores);
					dom.results.innerHTML = `<div class="results-header"><h2>${this.string('resultsTitle')}</h2></div><table><thead><tr><th style="width:20%">${this.string('rank')}</th><th style="width:60%">${this.string('item')}</th><th style="width:20%">${this.string('score')}</th></tr></thead><tbody>${ranking.map((index,i)=>`<tr><td>${i + 1}</td><td>${escape(this.items[index])}</td><td>${Math.round(this.scores[index])}</td></tr>`).join('')}</tbody></table>`;
					this.show('results');
					this.saveState();
				}

				show(section) {
					['inputSection', 'battleSection', 'results'].forEach(id=>dom[id].classList.toggle('hidden', id !== section));
					dom.restartWrap.classList.toggle('hidden', section !== 'results');
					dom.undo.classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
					dom.copy.classList.toggle('hidden', section !== 'results');
					this.keyboardEnabled = section === 'battleSection' || section === 'results';
					section === 'battleSection' && dom.battleSection.parentNode.insertBefore(dom.undo, dom.battleSection);
					section === 'results' && (dom.results.firstElementChild.prepend(dom.undo),
					dom.results.firstElementChild.appendChild(dom.copy));
					section === 'inputSection' && this.checkStartButton();
					const focusTarget = {
						battleSection: dom.left,
						results: dom.restartBattle,
						inputSection: dom.items
					}[section];
					focusTarget && setTimeout(()=>focusTarget.focus(), 50);
				}

				copyResults() {
					const ranking = this.provider.getRanking(this.scores);
					const headers = [this.string('rank'), this.string('item'), this.string('score')].join('\t');
					const lines = ranking.map((index,i)=>`${i + 1}\t${this.items[index]}\t${Math.round(this.scores[index])}`);
					navigator.clipboard.writeText([headers, ...lines].join('\n')).then(()=>{
						const original = dom.copy.textContent;
						dom.copy.textContent = this.string('copied');
						setTimeout(()=>dom.copy.textContent = original, 2000);
					}
					);
				}

				cancel() {
					const reset = ()=>{
						dom.cancel.classList.remove('confirming');
						dom.cancel.textContent = this.string('cancel');
						this.cancelTimeout = null;
					}
					;
					if (this.cancelTimeout) {
						clearTimeout(this.cancelTimeout);
						reset();
						return this.show('inputSection');
					}
					dom.cancel.textContent = this.string('confirmCancel');
					dom.cancel.classList.add('confirming');
					this.cancelTimeout = setTimeout(reset, 3000);
				}

				undo() {
					if (this.busy || !this.history.length)
						return;
					const last = this.history.pop();
					this.matches.pop();
					this.recalculateScores();
					Object.assign(this, {
						step: last.step,
						pair: last.pair,
						swapped: last.swapped
					});
					this.provider.unmark(last.pair);
					this.renderPair();
					this.show('battleSection');
					dom.undo.disabled = !this.history.length;
					this.saveState();
				}

				reset() {
					this.init();
					this.show('inputSection');
					this.updateHelp();
					this.updateProgress();
					this.saveState();
				}

				handleKey(event) {
					if (event.repeat)
						return;
					const {key, ctrlKey, metaKey, shiftKey} = event;
					if (key === 'Enter' && (ctrlKey || metaKey))
						return !dom.inputSection.classList.contains('hidden') && !dom.start.disabled && (event.preventDefault(),
						dom.start.click());
					const action = {
						arrowleft: 'left',
						arrowright: 'right',
						arrowup: 'tie',
						arrowdown: 'tie',
						z: 'undo'
					}[key.toLowerCase()];
					if (!action || !this.keyboardEnabled || /^(SELECT|INPUT|TEXTAREA)$/.test(document.activeElement.tagName))
						return;
					const valid = action === 'undo' ? (ctrlKey || metaKey) && !shiftKey : !dom.battleSection.classList.contains('hidden') && (action !== 'tie' || this.allowTies);
					valid && (event.preventDefault(),
					dom[action].click());
				}
			}

			new PreferenceRank();
		</script>
	</body>
</html>
