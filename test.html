<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test for unmark call on undo</title>
</head>
<body>
    <h1>Test for unmark call on undo</h1>
    <div id="test-results"></div>

    <!-- Include the PreferenceRank HTML structure -->
    <div class="container" style="display: none;">
        <div id="input">
            <div class="selectors">
                <select id="language">
                    <option value="en">English</option>
                    <option value="id">Bahasa Indonesia</option>
                </select>
                <select id="theme">
                    <option value="auto"></option>
                    <option value="light"></option>
                    <option value="dark"></option>
                </select>
            </div>
            <h1 id="title"></h1>
            <div class="group">
                <label for="items" id="itemsLabel"></label>
                <textarea id="items" rows="5" spellcheck="false"></textarea>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="allowTies">
                <label for="allowTies" id="allowTiesLabel"></label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="quickRank">
                <label for="quickRank" id="quickRankLabel"></label>
            </div>
            <button id="start" class="primary"></button>
        </div>
        <button id="undo" class="secondary hidden" disabled></button>
        <div id="battleSection" class="hidden">
            <div id="battle">
                <button id="left" class="secondary"></button>
                <button id="right" class="secondary"></button>
            </div>
            <div id="tieContainer" class="hidden">
                <button id="tie" class="secondary"></button>
            </div>
            <div id="progress"></div>
            <button id="shortcutToggle"></button>
            <div id="shortcutTip" class="hidden"></div>
        </div>
        <div id="results" class="hidden"></div>
        <div id="restartContainer" class="hidden">
            <button id="restartBattle" class="primary"></button>
            <button id="restartNew" class="primary"></button>
        </div>
    </div>

    <!-- Include the PreferenceRank script -->
    <script>
        const strings = {
            en: {
                title: 'PreferenceRank',
                autoTheme: 'Auto Theme',
                lightTheme: 'Light',
                darkTheme: 'Dark',
                itemsLabel: 'Enter items, one per line:',
                allowTiesLabel: 'Allow Ties',
                quickRankLabel: 'Use Quick Rank (fewer comparisons)',
                alert: 'Please enter at least two items.',
                duplicateAlert: '{count} duplicate item(s) were found and have been removed.',
                start: 'Start Ranking',
                tie: "It's a Tie",
                undo: 'Undo',
                progress: 'Progress',
                shortcutToggle: 'Show keyboard shortcuts',
                shortcutHide: 'Hide keyboard shortcuts',
                shortcutWithTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>↑</kbd> / <kbd>↓</kbd> It\'s a Tie<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
                shortcutNoTies: 'Keyboard Shortcuts:<br><kbd>←</kbd> Choose left item<br><kbd>→</kbd> Choose right item<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Undo last choice',
                resultsTitle: 'Results',
                rank: 'Rank',
                item: 'Item',
                score: 'Score',
                restartBattle: 'Restart Battle',
                restartNew: 'Start with New Items'
            },
            id: {
                title: 'PreferenceRank',
                autoTheme: 'Tema Otomatis',
                lightTheme: 'Terang',
                darkTheme: 'Gelap',
                itemsLabel: 'Masukkan pilihan, satu per baris:',
                allowTiesLabel: 'Izinkan Seri',
                quickRankLabel: 'Gunakan Peringkat Cepat (lebih sedikit perbandingan)',
                alert: 'Harap masukkan setidaknya dua pilihan.',
                duplicateAlert: '{count} item duplikat ditemukan dan telah dihapus.',
                start: 'Mulai Peringkat',
                tie: 'Seri',
                undo: 'Urungkan',
                progress: 'Kemajuan',
                shortcutToggle: 'Tampilkan pintasan papan ketik',
                shortcutHide: 'Sembunyikan pintasan papan ketik',
                shortcutWithTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>↑</kbd> / <kbd>↓</kbd> Seri<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
                shortcutNoTies: 'Pintasan Papan Ketik:<br><kbd>←</kbd> Pilih pilihan kiri<br><kbd>→</kbd> Pilih pilihan kanan<br><kbd>Ctrl/⌘</kbd>+<kbd>Z</kbd> Urungkan pilihan terakhir',
                resultsTitle: 'Hasil',
                rank: 'Peringkat',
                item: 'Nama',
                score: 'Skor',
                restartBattle: 'Mulai Ulang Pertarungan',
                restartNew: 'Mulai dengan Pilihan Baru'
            }
        };

        const escape = text => Object.assign(document.createElement('p'), {
            textContent: text
        }).innerHTML;

        class PairProvider {
            constructor(count) {
                this.count = count;
                this.compared = new Set();
            }
            key([a, b]) {
                return `${Math.min(a, b)}-${Math.max(a, b)}`;
            }
            mark(pair) {
                this.compared.add(this.key(pair));
            }
            unmark(pair) {
                this.compared.delete(this.key(pair));
            }
            has(pair) {
                return this.compared.has(this.key(pair));
            }
        }

        class FullPairProvider extends PairProvider {
            constructor(count) {
                super(count);
                this.pairs = [];
                for (let i = 0; i < count - 1; i++)
                    for (let j = i + 1; j < count; j++)
                        this.pairs.push([i, j]);
                for (let i = this.pairs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.pairs[i], this.pairs[j]] = [this.pairs[j], this.pairs[i]];
                }
            }
            next(state) {
                return this.pairs[state.step];
            }
            total() {
                return this.pairs.length;
            }
        }

        class QuickPairProvider extends PairProvider {
            next(state) {
                const sorted = Array.from({
                    length: this.count
                }, (_, i) => i).sort((a, b) => state.scores[b] - state.scores[a]);
                for (let i = 0; i < this.count - 1; i++) {
                    const pair = [sorted[i], sorted[i + 1]];
                    if (!this.has(pair))
                        return pair;
                }
                return null;
            }
        }

        class PreferenceRank {
            constructor() {
                this.el = Object.fromEntries([...document.querySelectorAll('[id]')].map(e => [e.id, e]));
                this.items = [];
                this.scores = [];
                this.pair = null;
                this.swapped = false;
                this.step = 0;
                this.total = 0;
                this.ties = false;
                this.history = [];
                this.keyboard = false;
                this.choosing = false;
                this.lang = navigator.language?.startsWith('id') ? 'id' : 'en';
                this.provider = null;
                this.swaps = new Map();
                this.init();
            }

            init() {
                this.bind();
                this.setTheme('auto');
                this.setLanguage(this.lang);
                this.undoOriginalParent = this.el.undo.parentNode;
                this.undoOriginalNextSibling = this.el.battleSection;
            }

            bind() {
                const {
                    el
                } = this;
                el.start.onclick = () => this.startRanking();
                el.left.onclick = () => this.choose('left');
                el.right.onclick = () => this.choose('right');
                el.tie.onclick = () => this.choose('tie');
                el.restartBattle.onclick = () => this.restart();
                el.restartNew.onclick = () => this.reset();
                el.undo.onclick = () => this.undoChoice();
                el.shortcutToggle.onclick = () => this.toggleShortcuts();
                el.language.onchange = e => this.setLanguage(e.target.value);
                el.theme.onchange = e => this.setTheme(e.target.value);
                el.allowTies.onchange = e => this.setTies(e.target.checked);
                document.onkeydown = e => this.handleKey(e);
            }

            t(key) {
                return strings[this.lang][key];
            }
            fmt(key, values) {
                let text = this.t(key);
                for (const [k, v] of Object.entries(values || {}))
                    text = text.replace(`{${k}}`, v);
                return text;
            }

            setTheme(theme) {
                document.documentElement.classList.remove('light', 'dark');
                if (theme !== 'auto')
                    document.documentElement.classList.add(theme);
                this.el.theme.value = theme;
            }

            setLanguage(lang) {
                this.lang = lang;
                this.el.language.value = lang;
                document.documentElement.lang = lang;
                const {
                    el
                } = this;
                const s = strings[lang];
                el.title.textContent = s.title;
                el.theme.options[0].textContent = s.autoTheme;
                el.theme.options[1].textContent = s.lightTheme;
                el.theme.options[2].textContent = s.darkTheme;
                el.itemsLabel.textContent = s.itemsLabel;
                el.allowTiesLabel.textContent = s.allowTiesLabel;
                el.quickRankLabel.textContent = s.quickRankLabel;
                el.start.textContent = s.start;
                el.tie.textContent = s.tie;
                el.undo.textContent = s.undo;
                el.restartBattle.textContent = s.restartBattle;
                el.restartNew.textContent = s.restartNew;
                this.updateShortcuts();
                this.updateProgress();
                if (!el.results.classList.contains('hidden'))
                    this.showResults();
            }

            setTies(enabled) {
                this.ties = enabled;
                if (!this.el.battleSection.classList.contains('hidden')) {
                    this.el.tieContainer.classList.toggle('hidden', !enabled);
                }
                this.updateShortcuts();
            }

            updateShortcuts() {
                const hidden = this.el.shortcutTip.classList.contains('hidden');
                this.el.shortcutToggle.textContent = hidden ? this.t('shortcutToggle') : this.t('shortcutHide');
                this.el.shortcutTip.innerHTML = this.t(this.ties ? 'shortcutWithTies' : 'shortcutNoTies');
            }

            toggleShortcuts(forceHide) {
                const hide = typeof forceHide === 'boolean' ? forceHide : !this.el.shortcutTip.classList.contains('hidden');
                this.el.shortcutTip.classList.toggle('hidden', hide);
                this.updateShortcuts();
            }

            initBattle() {
                const count = this.items.length;
                const quick = this.el.quickRank.checked;
                this.scores = Array(count).fill(1000);
                this.step = 0;
                this.history = [];
                this.swaps = new Map();
                this.el.undo.disabled = true;
                this.provider = quick ? new QuickPairProvider(count) : new FullPairProvider(count);
                this.total = quick ? 0 : this.provider.total();
            }

            startRanking() {
                const raw = this.el.items.value.split('\n').map(s => s.trim()).filter(Boolean);
                const unique = [...new Set(raw)];
                const dupes = raw.length - unique.length;
                if (dupes > 0)
                    alert(this.fmt('duplicateAlert', {
                        count: dupes
                    }));
                if (unique.length < 2)
                    return alert(this.t('alert'));

                this.items = unique;
                this.ties = this.el.allowTies.checked;
                this.initBattle();
                this.el.tieContainer.classList.toggle('hidden', !this.ties);
                this.toggleShortcuts(true);
                this.updateShortcuts();
                this.show('battleSection');
                this.nextBattle();
            }

            calcScores(winner) {
                const [first, second] = this.pair;
                const isFirst = (winner === 'left' && !this.swapped) || (winner === 'right' && this.swapped);
                const result = winner === 'tie' ? 0.5 : isFirst ? 1 : 0;
                const expected = 1 / (1 + 10 ** ((this.scores[second] - this.scores[first]) / 400));
                this.scores[first] += 32 * (result - expected);
                this.scores[second] += 32 * (expected - result);
            }

            choose(winner) {
                if (this.choosing)
                    return;
                this.choosing = true;

                this.history.push({
                    pair: this.pair,
                    scores: [...this.scores],
                    step: this.step,
                    swapped: this.swapped
                });
                this.provider.mark(this.pair);
                this.calcScores(winner);
                this.step++;
                this.el.undo.disabled = false;
                this.updateProgress();
                this.clearSelections();

                const btn = winner === 'tie' ? this.el.tie : this.el[winner];
                btn.classList.add('selected');

                setTimeout(() => {
                    this.choosing = false;
                    this.nextBattle();
                }, 300);
            }

            displayBattle() {
                this.clearSelections();
                let [first, second] = this.pair;
                if (this.swapped)
                    [first, second] = [second, first];
                this.el.left.textContent = this.items[first];
                this.el.right.textContent = this.items[second];
                this.updateProgress();
            }

            nextBattle() {
                this.clearSelections();
                const next = this.provider.next(this);
                const quick = this.el.quickRank.checked;
                if (!next || (!quick && this.step >= this.total))
                    return this.showResults();

                this.pair = next;
                const key = this.provider.key(next);
                if (!this.swaps.has(key))
                    this.swaps.set(key, Math..random() < 0.5);
                this.swapped = this.swaps.get(key);
                this.displayBattle();
            }

            updateProgress() {
                const quick = this.el.quickRank.checked;
                this.el.progress.textContent = `${this.t('progress')}: ${this.step}${quick ? '' : `/${this.total || 0}`}`;
            }

            clearSelections() {
                ['left', 'right', 'tie'].forEach(id => this.el[id].classList.remove('selected'));
            }

            showResults() {
                const results = this.items.map((item, i) => ({
                    item,
                    score: this.scores[i]
                })).sort((a, b) => b.score - a.score);
                this.el.results.innerHTML = `<div class="results-header"><h2>${this.t('resultsTitle')}</h2></div>
					<table><thead><tr><th style="width:20%">${this.t('rank')}</th><th style="width:60%">${this.t('item')}</th><th style="width:20%">${this.t('score')}</th></tr></thead>
					<tbody>${results.map((r, i) => `<tr><td>${i + 1}</td><td>${escape(r.item)}</td><td>${Math.round(r.score)}</td></tr>`).join('')}</tbody></table>`;
                this.show('results');
            }

            show(section) {
                ['input', 'battleSection', 'results'].forEach(id => this.el[id].classList.toggle('hidden', id !== section));
                this.el.restartContainer.classList.toggle('hidden', section !== 'results');
                this.el.undo.classList.toggle('hidden', section !== 'battleSection' && section !== 'results');
                this.keyboard = section === 'battleSection' || section === 'results';
                const undoActions = {
                    battleSection: () => this.undoOriginalParent.insertBefore(this.el.undo, this.undoOriginalNextSibling),
                    results: () => this.el.results.firstElementChild.appendChild(this.el.undo)
                };
                undoActions[section]?.();
            }

            undoChoice() {
                if (this.choosing || !this.history.length)
                    return;
                const last = this.history.pop();
                this.scores = last.scores;
                this.step = last.step;
                this.pair = last.pair;
                this.swapped = last.swapped;

                this.provider.unmark(last.pair);

                this.displayBattle();
                this.show('battleSection');
                this.el.undo.disabled = !this.history.length;
            }

            restart() {
                this.initBattle();
                this.show('battleSection');
                this.nextBattle();
            }

            reset() {
                this.items = [];
                this.scores = [];
                this.pair = null;
                this.swapped = false;
                this.step = 0;
                this.total = 0;
                this.ties = false;
                this.history = [];
                this.keyboard = false;
                this.choosing = false;
                this.provider = null;
                this.swaps = new Map();
                this.el.items.value = '';
                this.el.allowTies.checked = false;
                this.el.quickRank.checked = false;
                this.show('input');
                this.toggleShortcuts(true);
                this.updateProgress();
            }

            handleKey(event) {
                const tag = document.activeElement.tagName;
                if (!this.keyboard || ['SELECT', 'INPUT', 'TEXTAREA'].includes(tag))
                    return;

                const map = {
                    ArrowLeft: 'left',
                    ArrowRight: 'right',
                    ArrowUp: 'tie',
                    ArrowDown: 'tie',
                    z: 'undo',
                    Z: 'undo'
                };
                const target = map[event.key];
                if (!target)
                    return;

                const isUndo = event.key === 'z' || event.key === 'Z';
                const isArrow = event.key === 'ArrowUp' || event.key === 'ArrowDown';
                if (isUndo && !(event.ctrlKey || event.metaKey))
                    return;
                if (isUndo && event.shiftKey)
                    return;
                if (isArrow && !this.ties)
                    return;

                event.preventDefault();
                this.el[target].click();
            }
        }

        new PreferenceRank();
    </script>
    <script>
        // Test runner
        let unmarkCalled = false;
        const originalUnmark = PairProvider.prototype.unmark;
        PairProvider.prototype.unmark = function(...args) {
            unmarkCalled = true;
            originalUnmark.apply(this, args);
        };

        const app = new PreferenceRank();
        const resultsDiv = document.getElementById('test-results');

        function runTest() {
            // 1. Set up the items
            app.el.items.value = 'Item 1\nItem 2\nItem 3';

            // 2. Start ranking
            app.el.start.click();

            // 3. Make a choice
            app.el.left.click();

            // 4. Undo the choice
            setTimeout(() => {
                app.el.undo.click();

                // 5. Check if unmark was called
                setTimeout(() => {
                    if (unmarkCalled) {
                        resultsDiv.innerHTML = '<p style="color: green;">Test PASSED: unmark() was called on undo.</p>';
                        console.log('Test PASSED');
                    } else {
                        resultsDiv.innerHTML = '<p style="color: red;">Test FAILED: unmark() was not called on undo.</p>';
                        console.error('Test FAILED');
                    }
                }, 500);
            }, 500);
        }

        window.onload = runTest;
    </script>
</body>
</html>